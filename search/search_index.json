{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 This is a tutorial to guide you through the process of creating your very own functional Discord bot in Python. It aims to help you understand the basic concepts of making a Discord bot, and help you all the way up to advanced concepts and features. This tutorial aims to cover 2 main libraries at the same time, Nextcord and Disnake. Multiple code tabs will be used to show each library's implementation of the feature being explained, looking like this: nextcord.py disnake.py import nextcord import disnake For specific help with each of these libraries please join their respective support servers: Nextcord Disnake Warning This is a tutorial intended for beginners to advanced bot developers, however it is not meant for beginner programmers, and contains advanced topics such as asynchronous programming. It is recommended that you have a firm grasp on Python and some of its more advanced concepts before you start developing bots, but it is not a hard requirement. If you have persistence and the willingness to learn and search for things you don't understand as you go along, you can learn both Python and bot development at the same time. Note This tutorial is a guide to help you create bots, it is not meant for you to copy the code of, as this does not help you learn. I highly recommend that you do not directly copy code from here, since it will not help in the long run. Start the Tutorial!","title":"Home"},{"location":"#home","text":"This is a tutorial to guide you through the process of creating your very own functional Discord bot in Python. It aims to help you understand the basic concepts of making a Discord bot, and help you all the way up to advanced concepts and features. This tutorial aims to cover 2 main libraries at the same time, Nextcord and Disnake. Multiple code tabs will be used to show each library's implementation of the feature being explained, looking like this: nextcord.py disnake.py import nextcord import disnake For specific help with each of these libraries please join their respective support servers: Nextcord Disnake Warning This is a tutorial intended for beginners to advanced bot developers, however it is not meant for beginner programmers, and contains advanced topics such as asynchronous programming. It is recommended that you have a firm grasp on Python and some of its more advanced concepts before you start developing bots, but it is not a hard requirement. If you have persistence and the willingness to learn and search for things you don't understand as you go along, you can learn both Python and bot development at the same time. Note This tutorial is a guide to help you create bots, it is not meant for you to copy the code of, as this does not help you learn. I highly recommend that you do not directly copy code from here, since it will not help in the long run. Start the Tutorial!","title":"Home"},{"location":"credits/","text":"Credits \u00b6 This page is to give credit to people who have helped with this tutorial, or people without whom the tutorial couldn't exist. Rapptz/Danny , for creating discord.py to start with. Nextcord & Disnake development teams & contributors for continuing the libraries as forks. Anand , TizzySaurus, and other contributors to the previous version of this tutorial. Me , I made this :P","title":"Credits"},{"location":"credits/#credits","text":"This page is to give credit to people who have helped with this tutorial, or people without whom the tutorial couldn't exist. Rapptz/Danny , for creating discord.py to start with. Nextcord & Disnake development teams & contributors for continuing the libraries as forks. Anand , TizzySaurus, and other contributors to the previous version of this tutorial. Me , I made this :P","title":"Credits"},{"location":"tips/mentions/","text":"Allowed Mentions \u00b6 Allowed mentions are a way of telling Discord that you don't want to ping for certain mentions in your message. The different types of ping a message can have are @role pings, @everyone or @here pings, @user pings, and reply pings, all of which we can turn on and off pings for when mentioning. How do I use them? \u00b6 There're a couple of ways you can use allowed mentions in disnake and nextcord: disnake nextcord The first way we can set allowed mentions in the bot's constructor, and these will apply on all messages sent by the bot. To do this we need to import AllowedMentions from disnake: from disnake import AllowedMentions from disnake.ext.commands import Bot Next, we need to create the bot: bot = Bot ( command_prefix = \"!\" , allowed_mentions = AllowedMentions ( users = False , # Whether to ping individual user @mentions everyone = False , # Whether to ping @everyone or @here mentions roles = False , # Whether to ping role @mentions replied_user = False , # Whether to ping on replies to messages ), ) The example above will disable all pings in messages the bot sends, but you can toggle these as you like. Try making your bot send mentions with these settings to see allowed mentions in action! The next way of setting allowed mentions is when sending a message, or replying to one. Either way it uses the same keyword argument, so I'll just show sending a message normally, and you can adapt that to your own code. Again the first thing we need to do if we havent already is import discord.py so we can access the AllowedMentions class: from disnake import AllowedMentions from disnake.ext.commands import InterationContext , slash_command Now, I'll assume that we're in a cog, so I can create a command like this: @slash_command ( name = \"dontpingme\" , description = \"A command that doesn't ping anyone.\" , guild_ids = [ ... ]) async def dont_ping_me ( self , inter : InterationContext ) -> None : mentions = discord . AllowedMentions ( users = False , ) await inter . send ( f \"Hello, { ctx . author . mention } \" , allowed_mentions = mentions ) The first way we can set allowed mentions in the bot's constructor, and these will apply on all messages sent by the bot. To do this we need to import AllowedMentions from nextcord: from nextcord import AllowedMentions from nextcord.ext.commands import Bot Next, we need to create the bot: bot = Bot ( command_prefix = \"!\" , allowed_mentions = AllowedMentions ( users = False , # Whether to ping individual user @mentions everyone = False , # Whether to ping @everyone or @here mentions roles = False , # Whether to ping role @mentions replied_user = False , # Whether to ping on replies to messages ), ) The example above will disable all pings in messages the bot sends, but you can toggle these as you like. Try making your bot send mentions with these settings to see allowed mentions in action! The next way of setting allowed mentions is when sending a message, or replying to one. Either way it uses the same keyword argument, so I'll just show sending a message normally, and you can adapt that to your own code. Again the first thing we need to do if we havent already is import discord.py so we can access the AllowedMentions class: from nextcord import AllowedMentions , Interaction , slash_command Now, I'll assume that we're in a cog, so I can create a command like this: @slash_command ( name = \"dontpingme\" , description = \"A command that doesn't ping anyone.\" , guild_ids = [ ... ]) async def dont_ping_me ( self , inter : Interation ) -> None : mentions = discord . AllowedMentions ( users = False , ) await inter . send ( f \"Hello, { ctx . author . mention } \" , allowed_mentions = mentions ) This example only disabled the users mention, since it's the only one that will happen, which means now you can run that command and the bot will mention you, but won't ping you. Neat, huh? Info Note that when using allowed mentions in a message specifically, any mentions you have set in the AllowedMentions object will override those mentions' settings that were set in the bot's constructor.","title":"Allowed Mentions"},{"location":"tips/mentions/#allowed-mentions","text":"Allowed mentions are a way of telling Discord that you don't want to ping for certain mentions in your message. The different types of ping a message can have are @role pings, @everyone or @here pings, @user pings, and reply pings, all of which we can turn on and off pings for when mentioning.","title":"Allowed Mentions"},{"location":"tips/mentions/#how-do-i-use-them","text":"There're a couple of ways you can use allowed mentions in disnake and nextcord: disnake nextcord The first way we can set allowed mentions in the bot's constructor, and these will apply on all messages sent by the bot. To do this we need to import AllowedMentions from disnake: from disnake import AllowedMentions from disnake.ext.commands import Bot Next, we need to create the bot: bot = Bot ( command_prefix = \"!\" , allowed_mentions = AllowedMentions ( users = False , # Whether to ping individual user @mentions everyone = False , # Whether to ping @everyone or @here mentions roles = False , # Whether to ping role @mentions replied_user = False , # Whether to ping on replies to messages ), ) The example above will disable all pings in messages the bot sends, but you can toggle these as you like. Try making your bot send mentions with these settings to see allowed mentions in action! The next way of setting allowed mentions is when sending a message, or replying to one. Either way it uses the same keyword argument, so I'll just show sending a message normally, and you can adapt that to your own code. Again the first thing we need to do if we havent already is import discord.py so we can access the AllowedMentions class: from disnake import AllowedMentions from disnake.ext.commands import InterationContext , slash_command Now, I'll assume that we're in a cog, so I can create a command like this: @slash_command ( name = \"dontpingme\" , description = \"A command that doesn't ping anyone.\" , guild_ids = [ ... ]) async def dont_ping_me ( self , inter : InterationContext ) -> None : mentions = discord . AllowedMentions ( users = False , ) await inter . send ( f \"Hello, { ctx . author . mention } \" , allowed_mentions = mentions ) The first way we can set allowed mentions in the bot's constructor, and these will apply on all messages sent by the bot. To do this we need to import AllowedMentions from nextcord: from nextcord import AllowedMentions from nextcord.ext.commands import Bot Next, we need to create the bot: bot = Bot ( command_prefix = \"!\" , allowed_mentions = AllowedMentions ( users = False , # Whether to ping individual user @mentions everyone = False , # Whether to ping @everyone or @here mentions roles = False , # Whether to ping role @mentions replied_user = False , # Whether to ping on replies to messages ), ) The example above will disable all pings in messages the bot sends, but you can toggle these as you like. Try making your bot send mentions with these settings to see allowed mentions in action! The next way of setting allowed mentions is when sending a message, or replying to one. Either way it uses the same keyword argument, so I'll just show sending a message normally, and you can adapt that to your own code. Again the first thing we need to do if we havent already is import discord.py so we can access the AllowedMentions class: from nextcord import AllowedMentions , Interaction , slash_command Now, I'll assume that we're in a cog, so I can create a command like this: @slash_command ( name = \"dontpingme\" , description = \"A command that doesn't ping anyone.\" , guild_ids = [ ... ]) async def dont_ping_me ( self , inter : Interation ) -> None : mentions = discord . AllowedMentions ( users = False , ) await inter . send ( f \"Hello, { ctx . author . mention } \" , allowed_mentions = mentions ) This example only disabled the users mention, since it's the only one that will happen, which means now you can run that command and the bot will mention you, but won't ping you. Neat, huh? Info Note that when using allowed mentions in a message specifically, any mentions you have set in the AllowedMentions object will override those mentions' settings that were set in the bot's constructor.","title":"How do I use them?"},{"location":"tips/storage/","text":"Storing Data \u00b6 As your bot grows in features you'll probably want to store persistent data, and it's important to do this in the correct way, else you can make your life developing harder, and possibly compromise the functionality of your bot. Warning If you have one takeaway from this, let it be that JSON is not a database, and does not work as one, nor does CSV, or plain text files. JSON works well as a data transfer format, or for config files, but is not made for storing changeable persistent data. In addition to this, spreadsheets are not databases either. Neither Excel nor Google Sheets are acceptable replacements for actual databases. If I hear that you, the reader, is using a spreadhseet as a database I will feel very bad please do not do this! Databases You Can Use \u00b6 Warning Note that the following libraries are async libraries. discord.py is an async library too, so the libraries you use inside it should also be async to prevent blocking calls from stopping the event loop doing important things, such as heartbeating to the Discord gateway. PostgreSQL \u00b6 Postgres is a popular SQL database due to its large feature set and efficiency, and is generally a good choice when storing data in a bot. To use postgres in your bot you'll want to use a client library such as asyncpg which provides an easy interface for interacting with Postgres. MySQL / MariaDB \u00b6 MySQL or it's younger sibling MariaDB are also popular SQL databases which are also extremely commonly used. For most bots there will be no noticable difference between MySQL-based and Postgres, so it's really up to personal preference To use MySQL or MariaDB in your bot you'll want the aiomysql client library, which also provides an easy interface for interacting with MySQL. aiosqlite \u00b6 SQLite is a simple, fast, local database. It's a SQL database and can be easily used just about anywhere. It has similar use cases to the databases listed above. To use aiosqlite in your own bot you'll need the aiosqlite package installed. MongoDB \u00b6 MongoDB is a document store, not a relational database like MySQL or PostgreSQL, which means its usecases are slightly different. MongoDB is primarily for storing JSON-like objects but in a proper database so you don't need to handle file storage and other general shenanigans when storing data. To use MongoDB in your bot you'll want to use the motor client library. Motor also provides an easy interface for interacting with MongoDB, but in a very different way to the previous SQL databases mentioned, since it's fundamentally a different kind of database. Resources \u00b6 Resource Description asyncpg docs The official asyncpg documentation aiomysql docs The official aiomysql documentation aiosqlite docs The official aiosqlite documentation. motor docs The official motor documentation PostgreSQL tutorial A tutorial to help you learn how to use Postgres MySQL tutorial A tutorial to help you learn how to use MySQL and MariaDB","title":"Storing Data"},{"location":"tips/storage/#storing-data","text":"As your bot grows in features you'll probably want to store persistent data, and it's important to do this in the correct way, else you can make your life developing harder, and possibly compromise the functionality of your bot. Warning If you have one takeaway from this, let it be that JSON is not a database, and does not work as one, nor does CSV, or plain text files. JSON works well as a data transfer format, or for config files, but is not made for storing changeable persistent data. In addition to this, spreadsheets are not databases either. Neither Excel nor Google Sheets are acceptable replacements for actual databases. If I hear that you, the reader, is using a spreadhseet as a database I will feel very bad please do not do this!","title":"Storing Data"},{"location":"tips/storage/#databases-you-can-use","text":"Warning Note that the following libraries are async libraries. discord.py is an async library too, so the libraries you use inside it should also be async to prevent blocking calls from stopping the event loop doing important things, such as heartbeating to the Discord gateway.","title":"Databases You Can Use"},{"location":"tips/storage/#postgresql","text":"Postgres is a popular SQL database due to its large feature set and efficiency, and is generally a good choice when storing data in a bot. To use postgres in your bot you'll want to use a client library such as asyncpg which provides an easy interface for interacting with Postgres.","title":"PostgreSQL"},{"location":"tips/storage/#mysql-mariadb","text":"MySQL or it's younger sibling MariaDB are also popular SQL databases which are also extremely commonly used. For most bots there will be no noticable difference between MySQL-based and Postgres, so it's really up to personal preference To use MySQL or MariaDB in your bot you'll want the aiomysql client library, which also provides an easy interface for interacting with MySQL.","title":"MySQL / MariaDB"},{"location":"tips/storage/#aiosqlite","text":"SQLite is a simple, fast, local database. It's a SQL database and can be easily used just about anywhere. It has similar use cases to the databases listed above. To use aiosqlite in your own bot you'll need the aiosqlite package installed.","title":"aiosqlite"},{"location":"tips/storage/#mongodb","text":"MongoDB is a document store, not a relational database like MySQL or PostgreSQL, which means its usecases are slightly different. MongoDB is primarily for storing JSON-like objects but in a proper database so you don't need to handle file storage and other general shenanigans when storing data. To use MongoDB in your bot you'll want to use the motor client library. Motor also provides an easy interface for interacting with MongoDB, but in a very different way to the previous SQL databases mentioned, since it's fundamentally a different kind of database.","title":"MongoDB"},{"location":"tips/storage/#resources","text":"Resource Description asyncpg docs The official asyncpg documentation aiomysql docs The official aiomysql documentation aiosqlite docs The official aiosqlite documentation. motor docs The official motor documentation PostgreSQL tutorial A tutorial to help you learn how to use Postgres MySQL tutorial A tutorial to help you learn how to use MySQL and MariaDB","title":"Resources"},{"location":"tips/tokens/","text":"Storing Tokens and Secrets \u00b6 In this tip article I'll explain the 3 most common methods of storing tokens and application secrets. While this is focused on use in Nextcord and Disnake projects, the concepts and tools are applicable to any project, should you wish to use this as a general reference. Note that for these examples you should assume that there is a bot defined somewhere else in the code, and the line bot.run(token) is at the bottom. I won't show the bot code in each example to show just the necessary information, and make this applicable outside of Discord bots too. Warning You should put all files storing credentials in your .gitignore file if you're using Git, so that they are not accidentally uploaded to Github (or your preferred git hosting provider). .env files \u00b6 The most common method of storing tokens and secrets is to store them in a .env file. This is a file which is used by the python-dotenv package to load environment variables from. This is the most common way of storing tokens and secrets in almost all programming projects. Note You will need to install the python-dotenv package to use this method. Linux and Mac Windows python3 -m pip install python-dotenv py -3 -m pip install python-dotenv .env main.py TOKEN=your_token from os import environ from dotenv import load_dotenv load_dotenv () token = environ [ \"TOKEN\" ] Now that you've loaded the token into the token variable, you can use it to run the bot in the bot.run() method: bot . run ( token ) Importing from Python files \u00b6 Another technique you can use is to import the token from a Python file. This is far simpler than loading from a .env file as it requires no external modules and is just a regular Python import. Assuming you have a folder named private and in it a file called config.py , you can simply use the following code to import the token from it: private/config.py main.py token = \"your_token\" from private.config import token Now that you've loaded the token into the token variable, you can use it to run the bot in the bot.run() method: bot . run ( token ) YAML and JSON \u00b6 The last common technique is using YAML and JSON files to store your token. First, I'll assume you have either a config.yml or config.json file. You're free to use whichever of these two you like, just look at the correct section for your type. YAML \u00b6 Note You will need to install the pyyaml package to use this method. Linux and Mac Windows python3 -m pip install pyyaml py -3 -m pip install pyyaml config.yml main.py token: \"your_token\" from yaml import safe_load from pathlib import Path config = safe_load ( Path ( \"config.yml\" ) . read_text ()) token = config [ \"token\" ] JSON \u00b6 For JSON it's more simple than YAML since no non-standard modules are needed, simply create a file ( config.json ) and load it as follows: config.json main.py { \"token\" : \"your_token\" } from json import loads from pathlib import Path config = loads ( Path ( \"config.json\" ) . read_text ()) token = config [ \"token\" ]","title":"Storing Tokens and Secrets"},{"location":"tips/tokens/#storing-tokens-and-secrets","text":"In this tip article I'll explain the 3 most common methods of storing tokens and application secrets. While this is focused on use in Nextcord and Disnake projects, the concepts and tools are applicable to any project, should you wish to use this as a general reference. Note that for these examples you should assume that there is a bot defined somewhere else in the code, and the line bot.run(token) is at the bottom. I won't show the bot code in each example to show just the necessary information, and make this applicable outside of Discord bots too. Warning You should put all files storing credentials in your .gitignore file if you're using Git, so that they are not accidentally uploaded to Github (or your preferred git hosting provider).","title":"Storing Tokens and Secrets"},{"location":"tips/tokens/#env-files","text":"The most common method of storing tokens and secrets is to store them in a .env file. This is a file which is used by the python-dotenv package to load environment variables from. This is the most common way of storing tokens and secrets in almost all programming projects. Note You will need to install the python-dotenv package to use this method. Linux and Mac Windows python3 -m pip install python-dotenv py -3 -m pip install python-dotenv .env main.py TOKEN=your_token from os import environ from dotenv import load_dotenv load_dotenv () token = environ [ \"TOKEN\" ] Now that you've loaded the token into the token variable, you can use it to run the bot in the bot.run() method: bot . run ( token )","title":".env files"},{"location":"tips/tokens/#importing-from-python-files","text":"Another technique you can use is to import the token from a Python file. This is far simpler than loading from a .env file as it requires no external modules and is just a regular Python import. Assuming you have a folder named private and in it a file called config.py , you can simply use the following code to import the token from it: private/config.py main.py token = \"your_token\" from private.config import token Now that you've loaded the token into the token variable, you can use it to run the bot in the bot.run() method: bot . run ( token )","title":"Importing from Python files"},{"location":"tips/tokens/#yaml-and-json","text":"The last common technique is using YAML and JSON files to store your token. First, I'll assume you have either a config.yml or config.json file. You're free to use whichever of these two you like, just look at the correct section for your type.","title":"YAML and JSON"},{"location":"tips/tokens/#yaml","text":"Note You will need to install the pyyaml package to use this method. Linux and Mac Windows python3 -m pip install pyyaml py -3 -m pip install pyyaml config.yml main.py token: \"your_token\" from yaml import safe_load from pathlib import Path config = safe_load ( Path ( \"config.yml\" ) . read_text ()) token = config [ \"token\" ]","title":"YAML"},{"location":"tips/tokens/#json","text":"For JSON it's more simple than YAML since no non-standard modules are needed, simply create a file ( config.json ) and load it as follows: config.json main.py { \"token\" : \"your_token\" } from json import loads from pathlib import Path config = loads ( Path ( \"config.json\" ) . read_text ()) token = config [ \"token\" ]","title":"JSON"},{"location":"tutorial/","text":"Tutorial - Home \u00b6 Before you start, there's a few things you will need to start developing bots: Nextcord Disnake An install of Python 3.8 or higher. An install of the Nextcord library. Linux and Mac Windows python3 -m pip install nextcord py -3 -m pip install nextcord An install of Python 3.8 or higher. An install of the Disnake library. Linux and Mac Windows python3 -m pip install disnake py -3 -m pip install disnake A working knowledge of Python basics or the will to learn. Especially object oriented programming. If you're unfamiliar with OOP in Python you can check out this tutorial by Corey Schafer. Now that you have these things you're ready to start the tutorial! Take Me to the Tutorial! Show Me the Credits","title":"Tutorial - Home"},{"location":"tutorial/#tutorial-home","text":"Before you start, there's a few things you will need to start developing bots: Nextcord Disnake An install of Python 3.8 or higher. An install of the Nextcord library. Linux and Mac Windows python3 -m pip install nextcord py -3 -m pip install nextcord An install of Python 3.8 or higher. An install of the Disnake library. Linux and Mac Windows python3 -m pip install disnake py -3 -m pip install disnake A working knowledge of Python basics or the will to learn. Especially object oriented programming. If you're unfamiliar with OOP in Python you can check out this tutorial by Corey Schafer. Now that you have these things you're ready to start the tutorial! Take Me to the Tutorial! Show Me the Credits","title":"Tutorial - Home"},{"location":"tutorial/beginner/01-setup/","text":"Creating a Bot User \u00b6 Info To create a bot application your Discord account must have a verified email address. It is also recommended that you enable 2-factor-authentication to secure your account. The first step in creating a bot is to head over to the Discord Developer Portal where you'll be asked to log in to your Discord account if you're not already signed in. Once you've logged in you'll see a screen like this: You can now click the shiny blue New Application button in the top hand corner to get started creating a new application. After you click it you should see a box like this pop up: Enter a suitable name for your application, and make sure that it follow Discord's Terms of Service. This applies to the entire tutorial too - you should not be using this tutorial for purposes that violate Discord's Terms of Service, Community Guidelines, or Developer Terms. You can read the Terms of Service here , and the Developer Terms here . Warning As a rough overview here are some things you should know about the ToS: Don't abuse the API. Don't harass users. So don't randomly DM or spam them. Don't spam Discord. Generally actions performed by a bot should be caused by some user action like sending a message or adding a reaction. Don't post NSFW content in channels not marked as NSFW. This may seem obvious but a lot of bots allow NSFW content to be posted outside of NSFW channels. This is not allowed. For the purposes of this tutorial we'll be using the name WumpusBot , and this will be referred to in other places in the tutorial, for example screenshots of commands. After creating an application you'll see a screen like this: There's quite a lot of information on this screen, so for now we'll ignore most of it since it's out of scope for the beginning of this tutorial. Click on the Bot tab on the left hand side (marked by a jigsaw piece) to switch to the bot page. On this page you'll see a button that says Add Bot. Clicking this will prompt you asking whether you're sure you want to create a new bot (you can't delete bots since they're too cool to destroy), click Yes, do it! and now you have your very own bot. After creating a bot your screen will change to look like this: Below the username box you'll see a button that says Copy which copies your bot's authentication token to your clipboard. You'll want to keep this token safe and on hand so your bot can connect to Discord later on in the tutorial. Warning Make sure never to post your token anywhere publicly, else people will be able to log in as your bot, and perform actions against the Discord API as your bot. If you believe that your bot\u2019s token was leaked, be sure to go to it\u2019s developer portal page and click the Regenerate button to regenerate the token so that nobody can use the old one. Finally for this part, you need to add your bot to your server. To do this you first require the Manage Server permission in whatever server you plan on adding it to. You\u2019ll want to head over to the OAuth2 tab on the left of the developer portal (marked by a wrench), where you\u2019ll be able to choose the scopes you want for your bot. For now, just select the bot scope, as it\u2019s all that will be needed for this tutorial - at least at the beginning. Now you\u2019ll want to choose permissions for your bot based on what you want it to do. For WumpusBot, I\u2019ll start by giving it Send Messages , Embed Links , Attach Files , Manage Messages , and Add Reactions , although we may need more permissions later, but that will be handled within Discord itself. Warning There are almost no circumstances under which your bot will ever need the Administrator permission. If you do not absolutely need it, you should not have it, as bots with administrator can destroy servers in seconds by deleting channels, mass-banning members, and a multitude of other unpleasant actions. In the end your permissions should look like this: Now you can copy the URL in the box above, and paste it into your browser, then follow the steps to add the bot to your server of choice. As of late 2021 it is also possible to click invite links within Discord itself to add a bot to your server too. That's it for the first part of the tutorial, you've created your very own bot user on Discord. Now you just have to do the fun bit - adding features - after all, what's a bot without features?","title":"Creating a Bot User"},{"location":"tutorial/beginner/01-setup/#creating-a-bot-user","text":"Info To create a bot application your Discord account must have a verified email address. It is also recommended that you enable 2-factor-authentication to secure your account. The first step in creating a bot is to head over to the Discord Developer Portal where you'll be asked to log in to your Discord account if you're not already signed in. Once you've logged in you'll see a screen like this: You can now click the shiny blue New Application button in the top hand corner to get started creating a new application. After you click it you should see a box like this pop up: Enter a suitable name for your application, and make sure that it follow Discord's Terms of Service. This applies to the entire tutorial too - you should not be using this tutorial for purposes that violate Discord's Terms of Service, Community Guidelines, or Developer Terms. You can read the Terms of Service here , and the Developer Terms here . Warning As a rough overview here are some things you should know about the ToS: Don't abuse the API. Don't harass users. So don't randomly DM or spam them. Don't spam Discord. Generally actions performed by a bot should be caused by some user action like sending a message or adding a reaction. Don't post NSFW content in channels not marked as NSFW. This may seem obvious but a lot of bots allow NSFW content to be posted outside of NSFW channels. This is not allowed. For the purposes of this tutorial we'll be using the name WumpusBot , and this will be referred to in other places in the tutorial, for example screenshots of commands. After creating an application you'll see a screen like this: There's quite a lot of information on this screen, so for now we'll ignore most of it since it's out of scope for the beginning of this tutorial. Click on the Bot tab on the left hand side (marked by a jigsaw piece) to switch to the bot page. On this page you'll see a button that says Add Bot. Clicking this will prompt you asking whether you're sure you want to create a new bot (you can't delete bots since they're too cool to destroy), click Yes, do it! and now you have your very own bot. After creating a bot your screen will change to look like this: Below the username box you'll see a button that says Copy which copies your bot's authentication token to your clipboard. You'll want to keep this token safe and on hand so your bot can connect to Discord later on in the tutorial. Warning Make sure never to post your token anywhere publicly, else people will be able to log in as your bot, and perform actions against the Discord API as your bot. If you believe that your bot\u2019s token was leaked, be sure to go to it\u2019s developer portal page and click the Regenerate button to regenerate the token so that nobody can use the old one. Finally for this part, you need to add your bot to your server. To do this you first require the Manage Server permission in whatever server you plan on adding it to. You\u2019ll want to head over to the OAuth2 tab on the left of the developer portal (marked by a wrench), where you\u2019ll be able to choose the scopes you want for your bot. For now, just select the bot scope, as it\u2019s all that will be needed for this tutorial - at least at the beginning. Now you\u2019ll want to choose permissions for your bot based on what you want it to do. For WumpusBot, I\u2019ll start by giving it Send Messages , Embed Links , Attach Files , Manage Messages , and Add Reactions , although we may need more permissions later, but that will be handled within Discord itself. Warning There are almost no circumstances under which your bot will ever need the Administrator permission. If you do not absolutely need it, you should not have it, as bots with administrator can destroy servers in seconds by deleting channels, mass-banning members, and a multitude of other unpleasant actions. In the end your permissions should look like this: Now you can copy the URL in the box above, and paste it into your browser, then follow the steps to add the bot to your server of choice. As of late 2021 it is also possible to click invite links within Discord itself to add a bot to your server too. That's it for the first part of the tutorial, you've created your very own bot user on Discord. Now you just have to do the fun bit - adding features - after all, what's a bot without features?","title":"Creating a Bot User"},{"location":"tutorial/beginner/02-overview/","text":"An Overview of Discord \u00b6 If you already have a decent understanding of WebSockets, the Discord API, and general Discord terminology, you can likely skip ahead to the next part in the tutorial. 1: The Gateway \u00b6 The gateway is just the Discord name for a WebSocket connection to Discord, following a specific protocol of packets that we need to send and receive. This is our bot's primary connection to Discord and means that instead of asking Discord repeatedly for events that have happened (known as polling), we just tell Discord which events we want to receive via gateway intents, and Discord will send us those events over the persistent socket we have connected with. When using client libraries like Nextcord and Disnake we don't need to worry too much about how this happens at such a low level, but it can help you to understand how each of the cogs in the machine works. Often it's helpful to understand the low-level architecture of a service like Discord, as it gives you a better understanding of how the service works at a higher level. Upon receiving an event from the gateway, the library will check the OP code of the packet, and then call the appropriate function in the library. Many of these OP codes are internal, such as resuming a session, identifying the client, and sending heartbeats, but some, like OP 10 (READY), are also dispatched as user facing events (specifically on_ready in this instance). Events with OP 0 - dispatch events, are the ones we will primarily use, as they contain events like MESSAGE_CREATE, MEMBER_UPDATE, and all the other useful events for building a functional bot. That's pretty much it for the gateway at this level. There is a lot more detail that can be talked about with the gateway, but that's out of the scope of this tutorial, and if you're interested in further reading the official Discord documentation for the gateway can be found here . 2: The API \u00b6 The API is how out bots talk back to Discord. We're receiving events from the gateway which deliver information to our bot, but when we want to resond to one of these events, for example automatically deleting a message with banned words in it, we need to make a request to Discord's REST API telling it to delete that message. If you've ever sent a message on Discord, added a reaction, renamed a channel, or done just about any other action in the client, you've interacted with the API before, you just haven't seen it. Bots have most of the same endpoints available as regular users, bar a few like adding friends, blocking people, and joining guilds. They do, however, have certain features exclusive to bots, like the ability to lock emojis to members with a certain role. As with the gateway, API calls are done behind the scenes and you don't need to manually interact with the API. This is useful as it abstracts away the difficult points of passing headers and handling ratelimits. 3: Terminology \u00b6 In Discord there are a few special words for things which we need to understand and be able to differentiate between. The following table shows what a word means in the context of this tutorial. Term Description guild The internal word that Discord has for what you know as a server. user A Discord user, not containing information relating to a guild. member A Discord user, with guild context. You'll only receive members if you have the server members gateway intent enabled, which will be explained later, or sometimes in other events like voice state updates and as the author in message events. And that's pretty much it for this part of the tutorial. I hope this has given you at least some useful knowledge about roughly how Discord works, and now you can move on to the next part!","title":"An Overview of Discord"},{"location":"tutorial/beginner/02-overview/#an-overview-of-discord","text":"If you already have a decent understanding of WebSockets, the Discord API, and general Discord terminology, you can likely skip ahead to the next part in the tutorial.","title":"An Overview of Discord"},{"location":"tutorial/beginner/02-overview/#1-the-gateway","text":"The gateway is just the Discord name for a WebSocket connection to Discord, following a specific protocol of packets that we need to send and receive. This is our bot's primary connection to Discord and means that instead of asking Discord repeatedly for events that have happened (known as polling), we just tell Discord which events we want to receive via gateway intents, and Discord will send us those events over the persistent socket we have connected with. When using client libraries like Nextcord and Disnake we don't need to worry too much about how this happens at such a low level, but it can help you to understand how each of the cogs in the machine works. Often it's helpful to understand the low-level architecture of a service like Discord, as it gives you a better understanding of how the service works at a higher level. Upon receiving an event from the gateway, the library will check the OP code of the packet, and then call the appropriate function in the library. Many of these OP codes are internal, such as resuming a session, identifying the client, and sending heartbeats, but some, like OP 10 (READY), are also dispatched as user facing events (specifically on_ready in this instance). Events with OP 0 - dispatch events, are the ones we will primarily use, as they contain events like MESSAGE_CREATE, MEMBER_UPDATE, and all the other useful events for building a functional bot. That's pretty much it for the gateway at this level. There is a lot more detail that can be talked about with the gateway, but that's out of the scope of this tutorial, and if you're interested in further reading the official Discord documentation for the gateway can be found here .","title":"1: The Gateway"},{"location":"tutorial/beginner/02-overview/#2-the-api","text":"The API is how out bots talk back to Discord. We're receiving events from the gateway which deliver information to our bot, but when we want to resond to one of these events, for example automatically deleting a message with banned words in it, we need to make a request to Discord's REST API telling it to delete that message. If you've ever sent a message on Discord, added a reaction, renamed a channel, or done just about any other action in the client, you've interacted with the API before, you just haven't seen it. Bots have most of the same endpoints available as regular users, bar a few like adding friends, blocking people, and joining guilds. They do, however, have certain features exclusive to bots, like the ability to lock emojis to members with a certain role. As with the gateway, API calls are done behind the scenes and you don't need to manually interact with the API. This is useful as it abstracts away the difficult points of passing headers and handling ratelimits.","title":"2: The API"},{"location":"tutorial/beginner/02-overview/#3-terminology","text":"In Discord there are a few special words for things which we need to understand and be able to differentiate between. The following table shows what a word means in the context of this tutorial. Term Description guild The internal word that Discord has for what you know as a server. user A Discord user, not containing information relating to a guild. member A Discord user, with guild context. You'll only receive members if you have the server members gateway intent enabled, which will be explained later, or sometimes in other events like voice state updates and as the author in message events. And that's pretty much it for this part of the tutorial. I hope this has given you at least some useful knowledge about roughly how Discord works, and now you can move on to the next part!","title":"3: Terminology"},{"location":"tutorial/beginner/03-hello/","text":"Hello, world \u00b6 In this part we'll create a basic slash command which just responds with \"Hello, world!\" to a /hello command. From this point onwards it is expected that you have either Nextcord or Disnake installed, as well as Python 3.8 or above. Nextcord Disnake To start off with slash commands in Nextcord, we'll need to import the nextcord.Client class, and create an instance of it which we can create commands on: import nextcord client = nextcord . Client () Awesome! Now that we have an instance of the client, we can create a command which responds to the /hello command: @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) There's quite a lot going on in that snippet, so allow me to explain what it all does: @client.slash_command(...) is a decorator which tells Nextcord that this is a slash command. name=\"hello\" is the name of the command. description=\"A simple hello command.\" is the description of the command. guild_ids=[...] is a list of guild IDs which the command is registered in, these should be int IDs of the guilds you want to register the command in. If this is empty it will be registered in all guilds, taking up to an hour to globally register. async def hello(inter: nextcord.Interaction) -> None is the function which will be called when the command is triggered. await inter.response.send_message(\"Hello!\") is the response which will be sent to the user. Finally, we can connect our bot to Discord by using Client.run() : client . run ( \"YOUR_BOT_TOKEN\" ) To start off with slash commands in Disnake we'll need to import the commands.Bot class, and also the CommandInteraction class for later use when defining the command: from disnake import CommandInteraction from disnake.ext.commands import Bot bot = Bot () Warning Remember, how you name your variables is important! This variable should be named bot , as it is an instance of the Bot class, and not something like client , which is a different class entirely. Awesome! Now that we have an instance of the bot, we can create a command which responds to the /hello command: @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : CommandInteraction ) -> None : await inter . send ( \"Hello!\" ) There's quite a lot going on in that snippet, so allow me to explain what it all does: @bot.slash_command(...) is a decorator which tells Disnake that this is a slash command. name=\"hello\" is the name of the command. description=\"A simple hello command.\" is the description of the command. guild_ids=[...] is a list of guild IDs which the command is registered in, these should be int IDs of the guilds you want to register the command in. If this is empty it will be registered in all guilds, taking up to an hour to globally register. async def hello(inter: CommandInteraction) -> None is the function which will be called when the command is triggered. await inter.send(\"Hello!\") is the response which will be sent to the user. Finally, we can connect our bot to Discord by using Bot.run() : bot . run ( \"YOUR_BOT_TOKEN\" ) Warning Storing tokens in your code like this is dangerous, if you upload a sample of your code to somewhere like Pastebin people could get your token and use it maliciously. It is recommended that you always store tokens in an environment variable or file, which is ignored by your version control system like Git. See Storing Tokens and Secrets for more information about how to correctly store application credentials. In the end you should have a command that looks like this: vcokltfre used /hello WumpusBot BOT Hello! That's it for this part! You're now ready to move on to ever more green and complex pastures!","title":"Hello, world"},{"location":"tutorial/beginner/03-hello/#hello-world","text":"In this part we'll create a basic slash command which just responds with \"Hello, world!\" to a /hello command. From this point onwards it is expected that you have either Nextcord or Disnake installed, as well as Python 3.8 or above. Nextcord Disnake To start off with slash commands in Nextcord, we'll need to import the nextcord.Client class, and create an instance of it which we can create commands on: import nextcord client = nextcord . Client () Awesome! Now that we have an instance of the client, we can create a command which responds to the /hello command: @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) There's quite a lot going on in that snippet, so allow me to explain what it all does: @client.slash_command(...) is a decorator which tells Nextcord that this is a slash command. name=\"hello\" is the name of the command. description=\"A simple hello command.\" is the description of the command. guild_ids=[...] is a list of guild IDs which the command is registered in, these should be int IDs of the guilds you want to register the command in. If this is empty it will be registered in all guilds, taking up to an hour to globally register. async def hello(inter: nextcord.Interaction) -> None is the function which will be called when the command is triggered. await inter.response.send_message(\"Hello!\") is the response which will be sent to the user. Finally, we can connect our bot to Discord by using Client.run() : client . run ( \"YOUR_BOT_TOKEN\" ) To start off with slash commands in Disnake we'll need to import the commands.Bot class, and also the CommandInteraction class for later use when defining the command: from disnake import CommandInteraction from disnake.ext.commands import Bot bot = Bot () Warning Remember, how you name your variables is important! This variable should be named bot , as it is an instance of the Bot class, and not something like client , which is a different class entirely. Awesome! Now that we have an instance of the bot, we can create a command which responds to the /hello command: @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : CommandInteraction ) -> None : await inter . send ( \"Hello!\" ) There's quite a lot going on in that snippet, so allow me to explain what it all does: @bot.slash_command(...) is a decorator which tells Disnake that this is a slash command. name=\"hello\" is the name of the command. description=\"A simple hello command.\" is the description of the command. guild_ids=[...] is a list of guild IDs which the command is registered in, these should be int IDs of the guilds you want to register the command in. If this is empty it will be registered in all guilds, taking up to an hour to globally register. async def hello(inter: CommandInteraction) -> None is the function which will be called when the command is triggered. await inter.send(\"Hello!\") is the response which will be sent to the user. Finally, we can connect our bot to Discord by using Bot.run() : bot . run ( \"YOUR_BOT_TOKEN\" ) Warning Storing tokens in your code like this is dangerous, if you upload a sample of your code to somewhere like Pastebin people could get your token and use it maliciously. It is recommended that you always store tokens in an environment variable or file, which is ignored by your version control system like Git. See Storing Tokens and Secrets for more information about how to correctly store application credentials. In the end you should have a command that looks like this: vcokltfre used /hello WumpusBot BOT Hello! That's it for this part! You're now ready to move on to ever more green and complex pastures!","title":"Hello, world"},{"location":"tutorial/beginner/04-pong/","text":"A Ping Command \u00b6 So far our bot is pretty simple - you type /hello and the bot responds with \"Hello!\" as a static response, which isn't particularly interesting. In this tutorial part we'll use useful information from our bot - its gateway latency - to respond with a more interesting response about the bot's performance. Here's the code from the previous part: Nextcord Disnake import nextcord client = nextcord . Client () @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) from disnake import CommandInteraction from disnake.ext.commands import Bot bot = Bot () @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : CommandInteraction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) The code we will be writing in a second will go just above the bot.run() call. Firstly we'll start out by defining the command again: Nextcord Disnake @client . slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ], ) async def ping ( inter : nextcord . Interaction ) -> None : And next we'll add in the magical line which shows us the bot's latency: await inter . response . send_message ( f \"Pong! { client . latency * 1000 : .2f } ms\" ) @bot . slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ], ) async def ping ( inter : CommandInteraction ) -> None : And next we'll add in the magical line which shows us the bot's latency: await inter . send ( f \"Pong! { bot . latency * 1000 : .2f } ms\" ) Note The final line here is indented by one indent. Make sure to reflect this in your own code. Most of this you have seen before in the previous part, but the important bit is the line which says either: await inter.response.send_message(f\"Pong! {client.latency * 1000:.2f}ms\") (Nextcord) await inter.send(f\"Pong! {bot.latency * 1000:.2f}ms\") (Disnake) The latency property of the bot or client tells us in seconds how long it took for the Discord gateway to respond to us last time we sent it a heartbeat payload (which keeps the connection alive). We multiply this by 1000 to get the latency in milliseconds, which is better for being interpreted, and is more standard, and then we round it to 2 decimal places using the :.2f format specifier. Now you can once again run your bot - having changed the guild_ids=[...] to contain your own guild IDs - and you'll be able to use the command like this: vcokltfre used /ping WumpusBot BOT Pong! 23.5ms That's it for this part! Now you're ready to move on to the next part: listening for events!","title":"A Ping Command"},{"location":"tutorial/beginner/04-pong/#a-ping-command","text":"So far our bot is pretty simple - you type /hello and the bot responds with \"Hello!\" as a static response, which isn't particularly interesting. In this tutorial part we'll use useful information from our bot - its gateway latency - to respond with a more interesting response about the bot's performance. Here's the code from the previous part: Nextcord Disnake import nextcord client = nextcord . Client () @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) from disnake import CommandInteraction from disnake.ext.commands import Bot bot = Bot () @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : CommandInteraction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) The code we will be writing in a second will go just above the bot.run() call. Firstly we'll start out by defining the command again: Nextcord Disnake @client . slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ], ) async def ping ( inter : nextcord . Interaction ) -> None : And next we'll add in the magical line which shows us the bot's latency: await inter . response . send_message ( f \"Pong! { client . latency * 1000 : .2f } ms\" ) @bot . slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ], ) async def ping ( inter : CommandInteraction ) -> None : And next we'll add in the magical line which shows us the bot's latency: await inter . send ( f \"Pong! { bot . latency * 1000 : .2f } ms\" ) Note The final line here is indented by one indent. Make sure to reflect this in your own code. Most of this you have seen before in the previous part, but the important bit is the line which says either: await inter.response.send_message(f\"Pong! {client.latency * 1000:.2f}ms\") (Nextcord) await inter.send(f\"Pong! {bot.latency * 1000:.2f}ms\") (Disnake) The latency property of the bot or client tells us in seconds how long it took for the Discord gateway to respond to us last time we sent it a heartbeat payload (which keeps the connection alive). We multiply this by 1000 to get the latency in milliseconds, which is better for being interpreted, and is more standard, and then we round it to 2 decimal places using the :.2f format specifier. Now you can once again run your bot - having changed the guild_ids=[...] to contain your own guild IDs - and you'll be able to use the command like this: vcokltfre used /ping WumpusBot BOT Pong! 23.5ms That's it for this part! Now you're ready to move on to the next part: listening for events!","title":"A Ping Command"},{"location":"tutorial/beginner/05-listeners/","text":"Event Listeners \u00b6 While a lot of bot functionality can be implemented with slash commands, there are features that cannot be implemented like this. For example if you want to delete messages containing a certain keyword, you cannot do that with slash commands, but you can do it with listeners for other events, such as messages. Just like previous parts we'll want a basic bot to be set up. In this example we will be automatically deleting any message that contains the word \"badword\" in it. For simplicity I have removed the ping command from the basic bots below. Nextcord Disnake import nextcord client = nextcord . Client () @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) from disnake import CommandInteraction , Message from disnake.ext.commands import Bot bot = Bot () @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : CommandInteraction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note We are importing Message here so that we can typehint the message parameter of the on_message listener later on. Next we'll create a listener that will delete any message that contains the word \"badword\" in it, again this is inserted just above the bot.run() call: Nextcord Disnake @client . event async def on_message ( message : nextcord . Message ) -> None : if \"badword\" in message . content : await message . delete () @bot . listener () async def on_message ( message : Message ) -> None : if \"badword\" in message . content : await message . delete () Here's a breakdown of what we're doing here: @bot.listener() is a decorator which tells Disnake that this is an event listener. async def on_message(message: Message) -> None is the function which will be called when the event is triggered. message is the message that triggered the event. if \"badword\" in message.content is a check to see if the message contains the word \"badword\" in it. await message.delete() deletes the message the user sent. Note This is a very simple example of using a listener for events. Much more complex tasks can be achieved using listeners, but they are out of scope for this beginner part. More complex examples will be given in later intermediate parts.","title":"Event Listeners"},{"location":"tutorial/beginner/05-listeners/#event-listeners","text":"While a lot of bot functionality can be implemented with slash commands, there are features that cannot be implemented like this. For example if you want to delete messages containing a certain keyword, you cannot do that with slash commands, but you can do it with listeners for other events, such as messages. Just like previous parts we'll want a basic bot to be set up. In this example we will be automatically deleting any message that contains the word \"badword\" in it. For simplicity I have removed the ping command from the basic bots below. Nextcord Disnake import nextcord client = nextcord . Client () @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) from disnake import CommandInteraction , Message from disnake.ext.commands import Bot bot = Bot () @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : CommandInteraction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note We are importing Message here so that we can typehint the message parameter of the on_message listener later on. Next we'll create a listener that will delete any message that contains the word \"badword\" in it, again this is inserted just above the bot.run() call: Nextcord Disnake @client . event async def on_message ( message : nextcord . Message ) -> None : if \"badword\" in message . content : await message . delete () @bot . listener () async def on_message ( message : Message ) -> None : if \"badword\" in message . content : await message . delete () Here's a breakdown of what we're doing here: @bot.listener() is a decorator which tells Disnake that this is an event listener. async def on_message(message: Message) -> None is the function which will be called when the event is triggered. message is the message that triggered the event. if \"badword\" in message.content is a check to see if the message contains the word \"badword\" in it. await message.delete() deletes the message the user sent. Note This is a very simple example of using a listener for events. Much more complex tasks can be achieved using listeners, but they are out of scope for this beginner part. More complex examples will be given in later intermediate parts.","title":"Event Listeners"},{"location":"tutorial/intermediate/","text":"Intermediate - Home \u00b6 This section of the tutorial is for intermediate users of Nextcord and Disnake. It aims to cover more advanced features which are less common in smaller application, but which may be rewuired for larger projects. Note From this point onwards only library features will be explained. All Python feature knowledge is assumed. Continue for Nextcord Continue for Disnake","title":"Intermediate - Home"},{"location":"tutorial/intermediate/#intermediate-home","text":"This section of the tutorial is for intermediate users of Nextcord and Disnake. It aims to cover more advanced features which are less common in smaller application, but which may be rewuired for larger projects. Note From this point onwards only library features will be explained. All Python feature knowledge is assumed. Continue for Nextcord Continue for Disnake","title":"Intermediate - Home"},{"location":"tutorial/intermediate/disnake/11-cogs/","text":"Cogs \u00b6 Cogs are an important part of Disnake which allow you to organise your events and commands into different files. They represent a fairly drastic change in how you write your events, commands, and bots, so it's useful to do them early on before you have too much logic in your main file. Note Cogs require a basic understanding of OOP/classes in Python. If you're not familiar with this, check out the first video in Corey Schafer's OOP Tutorial . Now that we're using cogs we're going to abandon most of the code we have from previous parts, since it needs to change significantly to be used with cogs, and some of the functionality we've impelemnted so far isn't very useful anyway. Note In this part I'll refer to cogs and extensions, and the difference between both is important. A cog is a single class that inherits from Cog , which encapsulates commands and events. An extension is a collection of cogs which has a setup function and can be loaded via the bot's load_extension method, although you will often find extensions with just one cog. As with the previous parts we need to create a bot object, we'll do this in a file named main.py : main.py from disnake.ext.commands import Bot bot = Bot () bot . run ( \"YOUR_BOT_TOKEN\" ) Now, we need to create a file that we'll put our cog in, let's call it ping.py as we'll be putting a basic ping command in here: ping.py from disnake.ext.commands import Bot , Cog , CommandInteraction , slash_command class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot @slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ]) async def ping ( self , inter : CommandInteraction ) -> None : await inter . send ( f \"Pong! { self . bot . latency * 1000 : .2f } ms\" ) As you can probably see, a lot of this is similar to the ping command we made in part 4 of the beginner section. There are a couple of important parts to explain which are different: We're now using the slash_command decorator from disnake.ext.commands . We can no longer use the bot object to make decorators since we don't have the bot object as it's in another file. Everything is now in a class. This is a fundamental part of cogs, all of their functionality is encapsulated within a class. In this section of code: class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot What we're doing is defining a new cog, and letting it take a bot object in its constructor. We're doing this so that we can then access that bot object for the ping command so we can retrieve the bot's websocket latency. We still have a final piece of code we need to add to the cog's file in order for the cog to be registered, a setup function: ping.py # This goes at the bottom of the file. def setup ( self , bot : Bot ) -> None : bot . add_cog ( Ping ( bot )) This function is what disnake looks for when loading an extension, and the function signature will always be setup(self, bot: Bot) -> None . Finally, we need to load the cog in our main file: main.py from disnake.ext.commands import Bot bot = Bot () bot . load_extension ( \"ping\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note that when loading an extension we omit the .py extension. Extensions are loaded via Python imports behind the scenes, so we reference them in the same way we would write an import. If you have an extension in ./cogs/ping.py you would load it with bot.load_extension(\"cogs.ping\") .","title":"Cogs"},{"location":"tutorial/intermediate/disnake/11-cogs/#cogs","text":"Cogs are an important part of Disnake which allow you to organise your events and commands into different files. They represent a fairly drastic change in how you write your events, commands, and bots, so it's useful to do them early on before you have too much logic in your main file. Note Cogs require a basic understanding of OOP/classes in Python. If you're not familiar with this, check out the first video in Corey Schafer's OOP Tutorial . Now that we're using cogs we're going to abandon most of the code we have from previous parts, since it needs to change significantly to be used with cogs, and some of the functionality we've impelemnted so far isn't very useful anyway. Note In this part I'll refer to cogs and extensions, and the difference between both is important. A cog is a single class that inherits from Cog , which encapsulates commands and events. An extension is a collection of cogs which has a setup function and can be loaded via the bot's load_extension method, although you will often find extensions with just one cog. As with the previous parts we need to create a bot object, we'll do this in a file named main.py : main.py from disnake.ext.commands import Bot bot = Bot () bot . run ( \"YOUR_BOT_TOKEN\" ) Now, we need to create a file that we'll put our cog in, let's call it ping.py as we'll be putting a basic ping command in here: ping.py from disnake.ext.commands import Bot , Cog , CommandInteraction , slash_command class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot @slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ]) async def ping ( self , inter : CommandInteraction ) -> None : await inter . send ( f \"Pong! { self . bot . latency * 1000 : .2f } ms\" ) As you can probably see, a lot of this is similar to the ping command we made in part 4 of the beginner section. There are a couple of important parts to explain which are different: We're now using the slash_command decorator from disnake.ext.commands . We can no longer use the bot object to make decorators since we don't have the bot object as it's in another file. Everything is now in a class. This is a fundamental part of cogs, all of their functionality is encapsulated within a class. In this section of code: class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot What we're doing is defining a new cog, and letting it take a bot object in its constructor. We're doing this so that we can then access that bot object for the ping command so we can retrieve the bot's websocket latency. We still have a final piece of code we need to add to the cog's file in order for the cog to be registered, a setup function: ping.py # This goes at the bottom of the file. def setup ( self , bot : Bot ) -> None : bot . add_cog ( Ping ( bot )) This function is what disnake looks for when loading an extension, and the function signature will always be setup(self, bot: Bot) -> None . Finally, we need to load the cog in our main file: main.py from disnake.ext.commands import Bot bot = Bot () bot . load_extension ( \"ping\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note that when loading an extension we omit the .py extension. Extensions are loaded via Python imports behind the scenes, so we reference them in the same way we would write an import. If you have an extension in ./cogs/ping.py you would load it with bot.load_extension(\"cogs.ping\") .","title":"Cogs"},{"location":"tutorial/intermediate/nextcord/11-cogs/","text":"Cogs \u00b6 Cogs are an important part of Nextcord which allow you to organise your events and commands into different files. They represent a fairly drastic change in how you write your events, commands, and bots, so it's useful to do them early on before you have too much logic in your main file. Note Cogs require a basic understanding of OOP/classes in Python. If you're not familiar with this, check out the first video in Corey Schafer's OOP Tutorial . Now that we're using cogs we're going to abandon most of the code we have from previous parts, since it needs to change significantly to be used with cogs, and some of the functionality we've impelemnted so far isn't very useful anyway. Note In this part I'll refer to cogs and extensions, and the difference between both is important. A cog is a single class that inherits from Cog , which encapsulates commands and events. An extension is a collection of cogs which has a setup function and can be loaded via the bot's load_extension method, although you will often find extensions with just one cog. As with the previous parts we need to create a bot object, we'll do this in a file named main.py : main.py from nextcord.ext.commands import Bot bot = Bot () bot . run ( \"YOUR_BOT_TOKEN\" ) Now, we need to create a file that we'll put our cog in, let's call it ping.py as we'll be putting a basic ping command in here: ping.py from nextcord import Interaction , slash_command from nextcord.ext.commands import Bot , Cog class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot @slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ]) async def ping ( self , inter : Interaction ) -> None : await inter . send ( f \"Pong! { self . bot . latency * 1000 : .2f } ms\" ) As you can probably see, a lot of this is similar to the ping command we made in part 4 of the beginner section. There are a couple of important parts to explain which are different: We're now using the slash_command decorator . We can no longer use the bot object to make decorators since we don't have the bot object as it's in another file. Everything is now in a class. This is a fundamental part of cogs, all of their functionality is encapsulated within a class. In this section of code: class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot What we're doing is defining a new cog, and letting it take a bot object in its constructor. We're doing this so that we can then access that bot object for the ping command so we can retrieve the bot's websocket latency. We still have a final piece of code we need to add to the cog's file in order for the cog to be registered, a setup function: ping.py # This goes at the bottom of the file. def setup ( self , bot : Bot ) -> None : bot . add_cog ( Ping ( bot )) This function is what nextcord looks for when loading an extension, and the function signature will always be setup(self, bot: Bot) -> None . Finally, we need to load the cog in our main file: main.py from nextcord.ext.commands import Bot bot = Bot () bot . load_extension ( \"ping\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note that when loading an extension we omit the .py extension. Extensions are loaded via Python imports behind the scenes, so we reference them in the same way we would write an import. If you have an extension in ./cogs/ping.py you would load it with bot.load_extension(\"cogs.ping\") .","title":"Cogs"},{"location":"tutorial/intermediate/nextcord/11-cogs/#cogs","text":"Cogs are an important part of Nextcord which allow you to organise your events and commands into different files. They represent a fairly drastic change in how you write your events, commands, and bots, so it's useful to do them early on before you have too much logic in your main file. Note Cogs require a basic understanding of OOP/classes in Python. If you're not familiar with this, check out the first video in Corey Schafer's OOP Tutorial . Now that we're using cogs we're going to abandon most of the code we have from previous parts, since it needs to change significantly to be used with cogs, and some of the functionality we've impelemnted so far isn't very useful anyway. Note In this part I'll refer to cogs and extensions, and the difference between both is important. A cog is a single class that inherits from Cog , which encapsulates commands and events. An extension is a collection of cogs which has a setup function and can be loaded via the bot's load_extension method, although you will often find extensions with just one cog. As with the previous parts we need to create a bot object, we'll do this in a file named main.py : main.py from nextcord.ext.commands import Bot bot = Bot () bot . run ( \"YOUR_BOT_TOKEN\" ) Now, we need to create a file that we'll put our cog in, let's call it ping.py as we'll be putting a basic ping command in here: ping.py from nextcord import Interaction , slash_command from nextcord.ext.commands import Bot , Cog class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot @slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ]) async def ping ( self , inter : Interaction ) -> None : await inter . send ( f \"Pong! { self . bot . latency * 1000 : .2f } ms\" ) As you can probably see, a lot of this is similar to the ping command we made in part 4 of the beginner section. There are a couple of important parts to explain which are different: We're now using the slash_command decorator . We can no longer use the bot object to make decorators since we don't have the bot object as it's in another file. Everything is now in a class. This is a fundamental part of cogs, all of their functionality is encapsulated within a class. In this section of code: class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot What we're doing is defining a new cog, and letting it take a bot object in its constructor. We're doing this so that we can then access that bot object for the ping command so we can retrieve the bot's websocket latency. We still have a final piece of code we need to add to the cog's file in order for the cog to be registered, a setup function: ping.py # This goes at the bottom of the file. def setup ( self , bot : Bot ) -> None : bot . add_cog ( Ping ( bot )) This function is what nextcord looks for when loading an extension, and the function signature will always be setup(self, bot: Bot) -> None . Finally, we need to load the cog in our main file: main.py from nextcord.ext.commands import Bot bot = Bot () bot . load_extension ( \"ping\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note that when loading an extension we omit the .py extension. Extensions are loaded via Python imports behind the scenes, so we reference them in the same way we would write an import. If you have an extension in ./cogs/ping.py you would load it with bot.load_extension(\"cogs.ping\") .","title":"Cogs"}]}