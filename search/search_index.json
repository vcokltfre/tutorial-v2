{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 This is a tutorial to guide you through the process of creating your very own functional Discord bot in Python. It aims to help you understand the basic concepts of making a Discord bot, and help you all the way up to advanced concepts and features. This tutorial aims to cover 2 main libraries at the same time, Nextcord and Disnake. Multiple code tabs will be used to show each library's implementation of the feature being explained, looking like this: nextcord_example.py disnake_example.py import nextcord import disnake For specific help with each of these libraries please join their respective support servers: Nextcord Disnake Warning This is a tutorial intended for beginners to advanced bot developers, however it is not meant for beginner programmers, and contains advanced topics such as asynchronous programming. It is recommended that you have a firm grasp on Python and some of its more advanced concepts before you start developing bots, but it is not a hard requirement. If you have persistence and the willingness to learn and search for things you don't understand as you go along, you can learn both Python and bot development at the same time. Note This tutorial is a guide to help you create bots, it is not meant for you to copy the code of, as this does not help you learn. I highly recommend that you do not directly copy code from here, since it will not help in the long run. Start the Tutorial!","title":"Home"},{"location":"#home","text":"This is a tutorial to guide you through the process of creating your very own functional Discord bot in Python. It aims to help you understand the basic concepts of making a Discord bot, and help you all the way up to advanced concepts and features. This tutorial aims to cover 2 main libraries at the same time, Nextcord and Disnake. Multiple code tabs will be used to show each library's implementation of the feature being explained, looking like this: nextcord_example.py disnake_example.py import nextcord import disnake For specific help with each of these libraries please join their respective support servers: Nextcord Disnake Warning This is a tutorial intended for beginners to advanced bot developers, however it is not meant for beginner programmers, and contains advanced topics such as asynchronous programming. It is recommended that you have a firm grasp on Python and some of its more advanced concepts before you start developing bots, but it is not a hard requirement. If you have persistence and the willingness to learn and search for things you don't understand as you go along, you can learn both Python and bot development at the same time. Note This tutorial is a guide to help you create bots, it is not meant for you to copy the code of, as this does not help you learn. I highly recommend that you do not directly copy code from here, since it will not help in the long run. Start the Tutorial!","title":"Home"},{"location":"credits/","text":"Credits \u00b6 This page is to give credit to people who have helped with this tutorial, or people without whom the tutorial couldn't exist. Rapptz/Danny , for creating discord.py to start with. Nextcord & Disnake development teams & contributors for continuing the libraries as forks. Anand , TizzySaurus, and other contributors to the previous version of this tutorial. Me , I made this :P","title":"Credits"},{"location":"credits/#credits","text":"This page is to give credit to people who have helped with this tutorial, or people without whom the tutorial couldn't exist. Rapptz/Danny , for creating discord.py to start with. Nextcord & Disnake development teams & contributors for continuing the libraries as forks. Anand , TizzySaurus, and other contributors to the previous version of this tutorial. Me , I made this :P","title":"Credits"},{"location":"tips/blocking/","text":"Blocking vs Non-Blocking IO \u00b6 Blocking and non-blocking are two terms you'll see pop up fairly frequently when developing Discord bots, since Discord is an inherently asynchronous platform. When creating a bot in Python you'll almost certainly be using async libraries such as discord.py, nextcord, disnake, and Hikari. These libraries use another library internally called asyncio . The asyncio library means, at a high level, that you can do multiple things at the same time in your code. What is concurrency? \u00b6 Concurrent code is code which runs at the same time as other code within the same process. There are a couple of methods to achieve concurrency in Python. One method is to use an operating system construct called threads (via the threading library in Python). Threads are OS managed concurrency, essentially the OS decides when code runs, which can cause confusion and data to be modified when it's unexpected, so is now often avoided. The second method of creating concurrent code is by using async/await , which is now often built into programming languages. For example, Python, JavaScript, and Rust all come with features which allow for concurrently executing code via async/await \u00b9 . This is known as cooperative multitasking/concurrency because the programmer decides when to hand control back to the event loop, which is in charge of scheduling the execution of tasks. This is the type of concurrency we will focus on in this article. What is blocking? \u00b6 Blocking code is code that runs synchronously and thus blocks the event loop from being able to run multiple tasks in parallel. This has the effect of stopping the execution of all functions that are not the synchronous function, until the synchronous function has finished executing. This can be a big problem if you have lots of slow synchronous functions being called, as they will often block the event loop and prevent normal operation of the async tasks within it. In Discord bots this can lead to large slowdowns, or in the case of interactions they may fail entirely due to the interaction token being valid only for 3 seconds. In this case there is no way for the library to respond to that interaction, be it a slash command, button press, etc. As a result the user will be shown a message saying the interaction has failed, and you'll likely receive an error in the console saying the interaction couldn't be responded to. For this reason it's very important that any long-running operations or operations that do input/output are non-blocking functions. asyncio \u00b6 As mentioned above the way we do cooperative concurrency in Python is via the asyncio library, which is a standard library module in all modern Python versions, including all Python versions supported by libraries like discord.py. The basics \u00b6 In order to use asyncio at a very basic level there are a few things you absolutely must know about it. Firstly you need to understand what a coroutine is. A coroutine is an important construct in asyncio , and is the result of calling an async function. Let's say you define a function like the following: async def main () -> None : pass This is an async function, as denoted by the keyword async ahead of def . When this function is called regularly it returns a coroutine object. This object can then be awaited and the event loop will handle ensuring that it gets completed: coro = main () result = await coro () In this case the result will be None , since the function returns nothing, but the awaited coroutine will return whatever the function returns, the difference is that you must await it to get the result, which allows the event loop to schedule its execution among other coroutines operating effectively in parallel, giving the image of everything running at the same time. It's important to understand that async functions return coroutines, but in normal use, you'll simply await the call to an async function for clarity, such as this: result = await main () To run an async function there are two ways you need to know for now: Awaiting it from within another async function, as shown above. Running it using asyncio 's run method, which takes in a coroutine, as shown below: from asyncio import run async def main () -> None : print ( \"The async function has run!\" ) run ( main ()) Running this code should yield an output of The async function has run! into your console. More information \u00b6 For a more in depth tutorial about asyncio I'd recommend reading this Real Python article , which explains how more of it works in much more depth. References \u00b6 \u00b9 \u00b6 Golang also has concurrency built in as a first-class language feature called goroutines. Goroutines are lightweight and can be used for massive concurrency. If you're interested in learning more I'd recommend reading this Geeks for Geeks article .","title":"Blocking vs Non-Blocking IO"},{"location":"tips/blocking/#blocking-vs-non-blocking-io","text":"Blocking and non-blocking are two terms you'll see pop up fairly frequently when developing Discord bots, since Discord is an inherently asynchronous platform. When creating a bot in Python you'll almost certainly be using async libraries such as discord.py, nextcord, disnake, and Hikari. These libraries use another library internally called asyncio . The asyncio library means, at a high level, that you can do multiple things at the same time in your code.","title":"Blocking vs Non-Blocking IO"},{"location":"tips/blocking/#what-is-concurrency","text":"Concurrent code is code which runs at the same time as other code within the same process. There are a couple of methods to achieve concurrency in Python. One method is to use an operating system construct called threads (via the threading library in Python). Threads are OS managed concurrency, essentially the OS decides when code runs, which can cause confusion and data to be modified when it's unexpected, so is now often avoided. The second method of creating concurrent code is by using async/await , which is now often built into programming languages. For example, Python, JavaScript, and Rust all come with features which allow for concurrently executing code via async/await \u00b9 . This is known as cooperative multitasking/concurrency because the programmer decides when to hand control back to the event loop, which is in charge of scheduling the execution of tasks. This is the type of concurrency we will focus on in this article.","title":"What is concurrency?"},{"location":"tips/blocking/#what-is-blocking","text":"Blocking code is code that runs synchronously and thus blocks the event loop from being able to run multiple tasks in parallel. This has the effect of stopping the execution of all functions that are not the synchronous function, until the synchronous function has finished executing. This can be a big problem if you have lots of slow synchronous functions being called, as they will often block the event loop and prevent normal operation of the async tasks within it. In Discord bots this can lead to large slowdowns, or in the case of interactions they may fail entirely due to the interaction token being valid only for 3 seconds. In this case there is no way for the library to respond to that interaction, be it a slash command, button press, etc. As a result the user will be shown a message saying the interaction has failed, and you'll likely receive an error in the console saying the interaction couldn't be responded to. For this reason it's very important that any long-running operations or operations that do input/output are non-blocking functions.","title":"What is blocking?"},{"location":"tips/blocking/#asyncio","text":"As mentioned above the way we do cooperative concurrency in Python is via the asyncio library, which is a standard library module in all modern Python versions, including all Python versions supported by libraries like discord.py.","title":"asyncio"},{"location":"tips/blocking/#the-basics","text":"In order to use asyncio at a very basic level there are a few things you absolutely must know about it. Firstly you need to understand what a coroutine is. A coroutine is an important construct in asyncio , and is the result of calling an async function. Let's say you define a function like the following: async def main () -> None : pass This is an async function, as denoted by the keyword async ahead of def . When this function is called regularly it returns a coroutine object. This object can then be awaited and the event loop will handle ensuring that it gets completed: coro = main () result = await coro () In this case the result will be None , since the function returns nothing, but the awaited coroutine will return whatever the function returns, the difference is that you must await it to get the result, which allows the event loop to schedule its execution among other coroutines operating effectively in parallel, giving the image of everything running at the same time. It's important to understand that async functions return coroutines, but in normal use, you'll simply await the call to an async function for clarity, such as this: result = await main () To run an async function there are two ways you need to know for now: Awaiting it from within another async function, as shown above. Running it using asyncio 's run method, which takes in a coroutine, as shown below: from asyncio import run async def main () -> None : print ( \"The async function has run!\" ) run ( main ()) Running this code should yield an output of The async function has run! into your console.","title":"The basics"},{"location":"tips/blocking/#more-information","text":"For a more in depth tutorial about asyncio I'd recommend reading this Real Python article , which explains how more of it works in much more depth.","title":"More information"},{"location":"tips/blocking/#references","text":"","title":"References"},{"location":"tips/blocking/#1","text":"Golang also has concurrency built in as a first-class language feature called goroutines. Goroutines are lightweight and can be used for massive concurrency. If you're interested in learning more I'd recommend reading this Geeks for Geeks article .","title":"\u00b9"},{"location":"tips/jsondb/","text":"JSON as a Database \u00b6 TL;DR \u00b6 JSON is not suitable as a database. Do not use it to store persistent data, instead take a read of this tip part . JSON, quite simply, is not a database. It's not designed to be a data storage format, rather a way of transmitting data over a network. It's also often used as a way of doing configuration files for programs. There is no redundancy built in to JSON. JSON is just a format, and Python has libraries for it like json and ujson that let you load and dump it, sometimes to files, but that's all it does, write data to a file. There is no sort of DBMS (Database Management System), which means no sort of sophistication in how the data is stored, or built in ways to keep it safe and backed up, there's no built in encryption either - bear in mind in larger applications encryption may be necessary for GDPR/relevant data protection regulations compliance. JSON, unlike relational databases, has no way to store relational data, which is a very commonly needed way of storing data. Relational data, as the name may suggest, is data that relates to other data. For example if you have a table of users and a table of servers, the server table will probably have an owner field, where you'd reference a user from the users table. Note This point is only relevant for relational data, but since a lot of data stored by bots is relational in nature this is worth including. JSON is primarily a KV (key-value) format, for example {\"a\":\"b\"} where a is the key and b is the value, but what if you want to search not by that key but by a sub-key? Well, instead of being able to quickly use var[key] , which in a Python dictionary has a constant return time (for more info look up hash tables), you now have to iterate through every object in the dictionary and compare to find what you're looking for. Most relational database systems, like MySQL, MariaDB, and PostgreSQL have ways of indexing secondary fields apart from the primary key so that you can easily search by multiple attributes. For more info and resources about storing persistent data, please see this tip part .","title":"JSON as a Database"},{"location":"tips/jsondb/#json-as-a-database","text":"","title":"JSON as a Database"},{"location":"tips/jsondb/#tldr","text":"JSON is not suitable as a database. Do not use it to store persistent data, instead take a read of this tip part . JSON, quite simply, is not a database. It's not designed to be a data storage format, rather a way of transmitting data over a network. It's also often used as a way of doing configuration files for programs. There is no redundancy built in to JSON. JSON is just a format, and Python has libraries for it like json and ujson that let you load and dump it, sometimes to files, but that's all it does, write data to a file. There is no sort of DBMS (Database Management System), which means no sort of sophistication in how the data is stored, or built in ways to keep it safe and backed up, there's no built in encryption either - bear in mind in larger applications encryption may be necessary for GDPR/relevant data protection regulations compliance. JSON, unlike relational databases, has no way to store relational data, which is a very commonly needed way of storing data. Relational data, as the name may suggest, is data that relates to other data. For example if you have a table of users and a table of servers, the server table will probably have an owner field, where you'd reference a user from the users table. Note This point is only relevant for relational data, but since a lot of data stored by bots is relational in nature this is worth including. JSON is primarily a KV (key-value) format, for example {\"a\":\"b\"} where a is the key and b is the value, but what if you want to search not by that key but by a sub-key? Well, instead of being able to quickly use var[key] , which in a Python dictionary has a constant return time (for more info look up hash tables), you now have to iterate through every object in the dictionary and compare to find what you're looking for. Most relational database systems, like MySQL, MariaDB, and PostgreSQL have ways of indexing secondary fields apart from the primary key so that you can easily search by multiple attributes. For more info and resources about storing persistent data, please see this tip part .","title":"TL;DR"},{"location":"tips/mentions/","text":"Allowed Mentions \u00b6 Allowed mentions are a way of telling Discord that you don't want to ping for certain mentions in your message. The different types of ping a message can have are @role pings, @everyone or @here pings, @user pings, and reply pings, all of which we can turn on and off pings for when mentioning. How do I use them? \u00b6 There're a couple of ways you can use allowed mentions in disnake and nextcord: disnake nextcord The first way we can set allowed mentions in the bot's constructor, and these will apply on all messages sent by the bot. To do this we need to import AllowedMentions from disnake: from disnake import AllowedMentions from disnake.ext.commands import Bot Next, we need to create the bot: bot = Bot ( command_prefix = \"!\" , allowed_mentions = AllowedMentions ( users = False , # Whether to ping individual user @mentions everyone = False , # Whether to ping @everyone or @here mentions roles = False , # Whether to ping role @mentions replied_user = False , # Whether to ping on replies to messages ), ) The example above will disable all pings in messages the bot sends, but you can toggle these as you like. Try making your bot send mentions with these settings to see allowed mentions in action! The next way of setting allowed mentions is when sending a message, or replying to one. Either way it uses the same keyword argument, so I'll just show sending a message normally, and you can adapt that to your own code. Again the first thing we need to do if we haven't already is import discord.py so we can access the AllowedMentions class: from disnake import AllowedMentions from disnake.ext.commands import InteractionContext , slash_command Now, I'll assume that we're in a cog, so I can create a command like this: @slash_command ( name = \"dontpingme\" , description = \"A command that doesn't ping anyone.\" , guild_ids = [ ... ]) async def dont_ping_me ( self , inter : InteractionContext ) -> None : mentions = discord . AllowedMentions ( users = False , ) await inter . send ( f \"Hello, { ctx . author . mention } \" , allowed_mentions = mentions ) The first way we can set allowed mentions in the bot's constructor, and these will apply on all messages sent by the bot. To do this we need to import AllowedMentions from nextcord: from nextcord import AllowedMentions from nextcord.ext.commands import Bot Next, we need to create the bot: bot = Bot ( command_prefix = \"!\" , allowed_mentions = AllowedMentions ( users = False , # Whether to ping individual user @mentions everyone = False , # Whether to ping @everyone or @here mentions roles = False , # Whether to ping role @mentions replied_user = False , # Whether to ping on replies to messages ), ) The example above will disable all pings in messages the bot sends, but you can toggle these as you like. Try making your bot send mentions with these settings to see allowed mentions in action! The next way of setting allowed mentions is when sending a message, or replying to one. Either way it uses the same keyword argument, so I'll just show sending a message normally, and you can adapt that to your own code. Again the first thing we need to do if we haven't already is import discord.py so we can access the AllowedMentions class: from nextcord import AllowedMentions , Interaction , slash_command Now, I'll assume that we're in a cog, so I can create a command like this: @slash_command ( name = \"dontpingme\" , description = \"A command that doesn't ping anyone.\" , guild_ids = [ ... ]) async def dont_ping_me ( self , inter : Interaction ) -> None : mentions = discord . AllowedMentions ( users = False , ) await inter . send ( f \"Hello, { ctx . author . mention } \" , allowed_mentions = mentions ) This example only disabled the users mention, since it's the only one that will happen, which means now you can run that command and the bot will mention you, but won't ping you. Neat, huh? Info Note that when using allowed mentions in a message specifically, any mentions you have set in the AllowedMentions object will override those mentions' settings that were set in the bot's constructor.","title":"Allowed Mentions"},{"location":"tips/mentions/#allowed-mentions","text":"Allowed mentions are a way of telling Discord that you don't want to ping for certain mentions in your message. The different types of ping a message can have are @role pings, @everyone or @here pings, @user pings, and reply pings, all of which we can turn on and off pings for when mentioning.","title":"Allowed Mentions"},{"location":"tips/mentions/#how-do-i-use-them","text":"There're a couple of ways you can use allowed mentions in disnake and nextcord: disnake nextcord The first way we can set allowed mentions in the bot's constructor, and these will apply on all messages sent by the bot. To do this we need to import AllowedMentions from disnake: from disnake import AllowedMentions from disnake.ext.commands import Bot Next, we need to create the bot: bot = Bot ( command_prefix = \"!\" , allowed_mentions = AllowedMentions ( users = False , # Whether to ping individual user @mentions everyone = False , # Whether to ping @everyone or @here mentions roles = False , # Whether to ping role @mentions replied_user = False , # Whether to ping on replies to messages ), ) The example above will disable all pings in messages the bot sends, but you can toggle these as you like. Try making your bot send mentions with these settings to see allowed mentions in action! The next way of setting allowed mentions is when sending a message, or replying to one. Either way it uses the same keyword argument, so I'll just show sending a message normally, and you can adapt that to your own code. Again the first thing we need to do if we haven't already is import discord.py so we can access the AllowedMentions class: from disnake import AllowedMentions from disnake.ext.commands import InteractionContext , slash_command Now, I'll assume that we're in a cog, so I can create a command like this: @slash_command ( name = \"dontpingme\" , description = \"A command that doesn't ping anyone.\" , guild_ids = [ ... ]) async def dont_ping_me ( self , inter : InteractionContext ) -> None : mentions = discord . AllowedMentions ( users = False , ) await inter . send ( f \"Hello, { ctx . author . mention } \" , allowed_mentions = mentions ) The first way we can set allowed mentions in the bot's constructor, and these will apply on all messages sent by the bot. To do this we need to import AllowedMentions from nextcord: from nextcord import AllowedMentions from nextcord.ext.commands import Bot Next, we need to create the bot: bot = Bot ( command_prefix = \"!\" , allowed_mentions = AllowedMentions ( users = False , # Whether to ping individual user @mentions everyone = False , # Whether to ping @everyone or @here mentions roles = False , # Whether to ping role @mentions replied_user = False , # Whether to ping on replies to messages ), ) The example above will disable all pings in messages the bot sends, but you can toggle these as you like. Try making your bot send mentions with these settings to see allowed mentions in action! The next way of setting allowed mentions is when sending a message, or replying to one. Either way it uses the same keyword argument, so I'll just show sending a message normally, and you can adapt that to your own code. Again the first thing we need to do if we haven't already is import discord.py so we can access the AllowedMentions class: from nextcord import AllowedMentions , Interaction , slash_command Now, I'll assume that we're in a cog, so I can create a command like this: @slash_command ( name = \"dontpingme\" , description = \"A command that doesn't ping anyone.\" , guild_ids = [ ... ]) async def dont_ping_me ( self , inter : Interaction ) -> None : mentions = discord . AllowedMentions ( users = False , ) await inter . send ( f \"Hello, { ctx . author . mention } \" , allowed_mentions = mentions ) This example only disabled the users mention, since it's the only one that will happen, which means now you can run that command and the bot will mention you, but won't ping you. Neat, huh? Info Note that when using allowed mentions in a message specifically, any mentions you have set in the AllowedMentions object will override those mentions' settings that were set in the bot's constructor.","title":"How do I use them?"},{"location":"tips/permissions/","text":"Bot Permissions \u00b6 Administrator \u00b6 Giving bots the administrator permission in your server is almost always a bad and dangerous idea, for several key reasons: In the case of a token leak your bot has the permissions to do anything in all the servers it is in. This means it can ban all members, remove all of the channels, post illegal material, anything. If you , the developer, make a mistake while programming the bot which causes your bot to - for example - remove all channels in a server by accident. People make mistakes, no matter how skilled or competent they are, and at some point having admin will cause issues when you make one of those mistakes. You can try as hard as you like not to make mistakes but they are inevitable and will happen. In general a best practice for security is the principle of least privilege. This means that nothing should have more privileged than it needs to operate, and it is highly unlikely that your bot actually warrants the administrator permission to function correctly. A common argument in favour of using this permission is \"if you're careful with your token and make sure it never gets leaked it's fine.\" No. As mentioned in point 2 people make mistakes. You are the weakest link in the security chain, and you have the capability to break it. How you should do permissions \u00b6 Figure out which permissions your bot actually needs to run. It helps to track the permissions each command/feature needs as you implement them so you don't need to scour your whole code at a later date to find them. Note all of these permissions somewhere for future reference. Make sure to note which features need which permissions, this will mean users can see why the bot needs a specific permission, and makes it easier for them to only give the permissions for the features they need from the bot. Add checks to your commands that ensure a bot has permissions to perform a command before the command logic is invoked. This will mean you can give your users more informative error messages about why the command can't run preemptively, rather than replying on later exceptions when the command is actually run. This can prevent unnecessary failed API calls.","title":"Bot Permissions"},{"location":"tips/permissions/#bot-permissions","text":"","title":"Bot Permissions"},{"location":"tips/permissions/#administrator","text":"Giving bots the administrator permission in your server is almost always a bad and dangerous idea, for several key reasons: In the case of a token leak your bot has the permissions to do anything in all the servers it is in. This means it can ban all members, remove all of the channels, post illegal material, anything. If you , the developer, make a mistake while programming the bot which causes your bot to - for example - remove all channels in a server by accident. People make mistakes, no matter how skilled or competent they are, and at some point having admin will cause issues when you make one of those mistakes. You can try as hard as you like not to make mistakes but they are inevitable and will happen. In general a best practice for security is the principle of least privilege. This means that nothing should have more privileged than it needs to operate, and it is highly unlikely that your bot actually warrants the administrator permission to function correctly. A common argument in favour of using this permission is \"if you're careful with your token and make sure it never gets leaked it's fine.\" No. As mentioned in point 2 people make mistakes. You are the weakest link in the security chain, and you have the capability to break it.","title":"Administrator"},{"location":"tips/permissions/#how-you-should-do-permissions","text":"Figure out which permissions your bot actually needs to run. It helps to track the permissions each command/feature needs as you implement them so you don't need to scour your whole code at a later date to find them. Note all of these permissions somewhere for future reference. Make sure to note which features need which permissions, this will mean users can see why the bot needs a specific permission, and makes it easier for them to only give the permissions for the features they need from the bot. Add checks to your commands that ensure a bot has permissions to perform a command before the command logic is invoked. This will mean you can give your users more informative error messages about why the command can't run preemptively, rather than replying on later exceptions when the command is actually run. This can prevent unnecessary failed API calls.","title":"How you should do permissions"},{"location":"tips/storage/","text":"Storing Data \u00b6 As your bot grows in features you'll probably want to store persistent data, and it's important to do this in the correct way, else you can make your life developing harder, and possibly compromise the functionality of your bot. Warning If you have one takeaway from this, let it be that JSON is not a database, and does not work as one, nor does CSV, or plain text files. JSON works well as a data transfer format, or for config files, but is not made for storing changeable persistent data. In addition to this, spreadsheets are not databases either. Neither Excel nor Google Sheets are acceptable replacements for actual databases. If I hear that you, the reader, is using a spreadsheet as a database I will feel very bad please do not do this! Databases You Can Use \u00b6 Warning Note that the following libraries are async libraries. discord.py is an async library too, so the libraries you use inside it should also be async to prevent blocking calls from stopping the event loop doing important things, such as heartbeating to the Discord gateway. PostgreSQL \u00b6 Postgres is a popular SQL database due to its large feature set and efficiency, and is generally a good choice when storing data in a bot. To use postgres in your bot you'll want to use a client library such as asyncpg which provides an easy interface for interacting with Postgres. MySQL / MariaDB \u00b6 MySQL or it's younger sibling MariaDB are also popular SQL databases which are also extremely commonly used. For most bots there will be no noticeable difference between MySQL-based and Postgres, so it's really up to personal preference To use MySQL or MariaDB in your bot you'll want the aiomysql client library, which also provides an easy interface for interacting with MySQL. aiosqlite \u00b6 SQLite is a simple, fast, local database. It's a SQL database and can be easily used just about anywhere. It has similar use cases to the databases listed above. To use aiosqlite in your own bot you'll need the aiosqlite package installed. MongoDB \u00b6 MongoDB is a document store, not a relational database like MySQL or PostgreSQL, which means its use cases are slightly different. MongoDB is primarily for storing JSON-like objects but in a proper database so you don't need to handle file storage and other general shenanigans when storing data. To use MongoDB in your bot you'll want to use the motor client library. Motor also provides an easy interface for interacting with MongoDB, but in a very different way to the previous SQL databases mentioned, since it's fundamentally a different kind of database. Connecting to Databases \u00b6 To use a database most libraries will require you explicitly make a call to connect() to the database, but where you do this is important. It can't be done before the bot is started because it will rely on the event loop to connect since the library you use should be async. Your first reaction might be to think that it should go in a handler for the READY event, but that's not the case. The READY event can be delivered multiple times by the Discord API, but we only wish to connect to the database once - when it's not already connected. Because of this it's preferable to subclass the Bot/Client class and override the start() method. The start method is an async function called right at the start of the bot's lifecycle, which makes it the ideal place to do initial async setup such as connecting to a database, retrieving data from an API, or starting background tasks. Depending on your bot's setup your code will likely look different, but if we wanted to do this with asyncpg in Disnake it might look like this: from asyncpg import Pool , connect from disnake import Bot class MyBot ( Bot ): pool : Pool async def start ( self , * args , ** kwargs ) -> None : self . pool = await connect ( \"postgres://user:password@localhost/database\" ) await super () . start () Resources \u00b6 Resource Description asyncpg docs The official asyncpg documentation aiomysql docs The official aiomysql documentation aiosqlite docs The official aiosqlite documentation. motor docs The official motor documentation PostgreSQL tutorial A tutorial to help you learn how to use Postgres MySQL tutorial A tutorial to help you learn how to use MySQL and MariaDB Ormar Docs Ormar documentation - an async ORM for PostgreSQL, MySQL, and SQLite","title":"Storing Data"},{"location":"tips/storage/#storing-data","text":"As your bot grows in features you'll probably want to store persistent data, and it's important to do this in the correct way, else you can make your life developing harder, and possibly compromise the functionality of your bot. Warning If you have one takeaway from this, let it be that JSON is not a database, and does not work as one, nor does CSV, or plain text files. JSON works well as a data transfer format, or for config files, but is not made for storing changeable persistent data. In addition to this, spreadsheets are not databases either. Neither Excel nor Google Sheets are acceptable replacements for actual databases. If I hear that you, the reader, is using a spreadsheet as a database I will feel very bad please do not do this!","title":"Storing Data"},{"location":"tips/storage/#databases-you-can-use","text":"Warning Note that the following libraries are async libraries. discord.py is an async library too, so the libraries you use inside it should also be async to prevent blocking calls from stopping the event loop doing important things, such as heartbeating to the Discord gateway.","title":"Databases You Can Use"},{"location":"tips/storage/#postgresql","text":"Postgres is a popular SQL database due to its large feature set and efficiency, and is generally a good choice when storing data in a bot. To use postgres in your bot you'll want to use a client library such as asyncpg which provides an easy interface for interacting with Postgres.","title":"PostgreSQL"},{"location":"tips/storage/#mysql-mariadb","text":"MySQL or it's younger sibling MariaDB are also popular SQL databases which are also extremely commonly used. For most bots there will be no noticeable difference between MySQL-based and Postgres, so it's really up to personal preference To use MySQL or MariaDB in your bot you'll want the aiomysql client library, which also provides an easy interface for interacting with MySQL.","title":"MySQL / MariaDB"},{"location":"tips/storage/#aiosqlite","text":"SQLite is a simple, fast, local database. It's a SQL database and can be easily used just about anywhere. It has similar use cases to the databases listed above. To use aiosqlite in your own bot you'll need the aiosqlite package installed.","title":"aiosqlite"},{"location":"tips/storage/#mongodb","text":"MongoDB is a document store, not a relational database like MySQL or PostgreSQL, which means its use cases are slightly different. MongoDB is primarily for storing JSON-like objects but in a proper database so you don't need to handle file storage and other general shenanigans when storing data. To use MongoDB in your bot you'll want to use the motor client library. Motor also provides an easy interface for interacting with MongoDB, but in a very different way to the previous SQL databases mentioned, since it's fundamentally a different kind of database.","title":"MongoDB"},{"location":"tips/storage/#connecting-to-databases","text":"To use a database most libraries will require you explicitly make a call to connect() to the database, but where you do this is important. It can't be done before the bot is started because it will rely on the event loop to connect since the library you use should be async. Your first reaction might be to think that it should go in a handler for the READY event, but that's not the case. The READY event can be delivered multiple times by the Discord API, but we only wish to connect to the database once - when it's not already connected. Because of this it's preferable to subclass the Bot/Client class and override the start() method. The start method is an async function called right at the start of the bot's lifecycle, which makes it the ideal place to do initial async setup such as connecting to a database, retrieving data from an API, or starting background tasks. Depending on your bot's setup your code will likely look different, but if we wanted to do this with asyncpg in Disnake it might look like this: from asyncpg import Pool , connect from disnake import Bot class MyBot ( Bot ): pool : Pool async def start ( self , * args , ** kwargs ) -> None : self . pool = await connect ( \"postgres://user:password@localhost/database\" ) await super () . start ()","title":"Connecting to Databases"},{"location":"tips/storage/#resources","text":"Resource Description asyncpg docs The official asyncpg documentation aiomysql docs The official aiomysql documentation aiosqlite docs The official aiosqlite documentation. motor docs The official motor documentation PostgreSQL tutorial A tutorial to help you learn how to use Postgres MySQL tutorial A tutorial to help you learn how to use MySQL and MariaDB Ormar Docs Ormar documentation - an async ORM for PostgreSQL, MySQL, and SQLite","title":"Resources"},{"location":"tips/tokens/","text":"Storing Tokens and Secrets \u00b6 In this tip article I'll explain the 3 most common methods of storing tokens and application secrets. While this is focused on use in Nextcord and Disnake projects, the concepts and tools are applicable to any project, should you wish to use this as a general reference. Note that for these examples you should assume that there is a bot defined somewhere else in the code, and the line bot.run(token) is at the bottom. I won't show the bot code in each example to show just the necessary information, and make this applicable outside of Discord bots too. Warning You should put all files storing credentials in your .gitignore file if you're using Git, so that they are not accidentally uploaded to Github (or your preferred git hosting provider). .env files \u00b6 The most common method of storing tokens and secrets is to store them in a .env file. This is a file which is used by the python-dotenv package to load environment variables from. This is the most common way of storing tokens and secrets in almost all programming projects. Note You will need to install the python-dotenv package to use this method. Linux and Mac Windows python3 -m pip install python-dotenv py -3 -m pip install python-dotenv .env main.py TOKEN=your_token from os import environ from dotenv import load_dotenv load_dotenv () token = environ [ \"TOKEN\" ] Now that you've loaded the token into the token variable, you can use it to run the bot in the bot.run() method: bot . run ( token ) Importing from Python files \u00b6 Another technique you can use is to import the token from a Python file. This is far simpler than loading from a .env file as it requires no external modules and is just a regular Python import. Assuming you have a folder named private and in it a file called config.py , you can simply use the following code to import the token from it: private/config.py main.py token = \"your_token\" from private.config import token Now that you've loaded the token into the token variable, you can use it to run the bot in the bot.run() method: bot . run ( token ) YAML and JSON \u00b6 The last common technique is using YAML and JSON files to store your token. First, I'll assume you have either a config.yml or config.json file. You're free to use whichever of these two you like, just look at the correct section for your type. YAML \u00b6 Note You will need to install the pyyaml package to use this method. Linux and Mac Windows python3 -m pip install pyyaml py -3 -m pip install pyyaml config.yml main.py token: \"your_token\" from yaml import safe_load from pathlib import Path config = safe_load ( Path ( \"config.yml\" ) . read_text ()) token = config [ \"token\" ] JSON \u00b6 For JSON it's more simple than YAML since no non-standard modules are needed, simply create a file ( config.json ) and load it as follows: config.json main.py { \"token\" : \"your_token\" } from json import loads from pathlib import Path config = loads ( Path ( \"config.json\" ) . read_text ()) token = config [ \"token\" ]","title":"Storing Tokens and Secrets"},{"location":"tips/tokens/#storing-tokens-and-secrets","text":"In this tip article I'll explain the 3 most common methods of storing tokens and application secrets. While this is focused on use in Nextcord and Disnake projects, the concepts and tools are applicable to any project, should you wish to use this as a general reference. Note that for these examples you should assume that there is a bot defined somewhere else in the code, and the line bot.run(token) is at the bottom. I won't show the bot code in each example to show just the necessary information, and make this applicable outside of Discord bots too. Warning You should put all files storing credentials in your .gitignore file if you're using Git, so that they are not accidentally uploaded to Github (or your preferred git hosting provider).","title":"Storing Tokens and Secrets"},{"location":"tips/tokens/#env-files","text":"The most common method of storing tokens and secrets is to store them in a .env file. This is a file which is used by the python-dotenv package to load environment variables from. This is the most common way of storing tokens and secrets in almost all programming projects. Note You will need to install the python-dotenv package to use this method. Linux and Mac Windows python3 -m pip install python-dotenv py -3 -m pip install python-dotenv .env main.py TOKEN=your_token from os import environ from dotenv import load_dotenv load_dotenv () token = environ [ \"TOKEN\" ] Now that you've loaded the token into the token variable, you can use it to run the bot in the bot.run() method: bot . run ( token )","title":".env files"},{"location":"tips/tokens/#importing-from-python-files","text":"Another technique you can use is to import the token from a Python file. This is far simpler than loading from a .env file as it requires no external modules and is just a regular Python import. Assuming you have a folder named private and in it a file called config.py , you can simply use the following code to import the token from it: private/config.py main.py token = \"your_token\" from private.config import token Now that you've loaded the token into the token variable, you can use it to run the bot in the bot.run() method: bot . run ( token )","title":"Importing from Python files"},{"location":"tips/tokens/#yaml-and-json","text":"The last common technique is using YAML and JSON files to store your token. First, I'll assume you have either a config.yml or config.json file. You're free to use whichever of these two you like, just look at the correct section for your type.","title":"YAML and JSON"},{"location":"tips/tokens/#yaml","text":"Note You will need to install the pyyaml package to use this method. Linux and Mac Windows python3 -m pip install pyyaml py -3 -m pip install pyyaml config.yml main.py token: \"your_token\" from yaml import safe_load from pathlib import Path config = safe_load ( Path ( \"config.yml\" ) . read_text ()) token = config [ \"token\" ]","title":"YAML"},{"location":"tips/tokens/#json","text":"For JSON it's more simple than YAML since no non-standard modules are needed, simply create a file ( config.json ) and load it as follows: config.json main.py { \"token\" : \"your_token\" } from json import loads from pathlib import Path config = loads ( Path ( \"config.json\" ) . read_text ()) token = config [ \"token\" ]","title":"JSON"},{"location":"tutorial/","text":"Tutorial - Home \u00b6 Before you start, there's a few things you will need to start developing bots: Nextcord Disnake An install of Python 3.8 or higher. An install of the Nextcord library. Linux and Mac Windows python3 -m pip install nextcord py -3 -m pip install nextcord An install of Python 3.8 or higher. An install of the Disnake library. Linux and Mac Windows python3 -m pip install disnake py -3 -m pip install disnake A working knowledge of Python basics or the will to learn. Especially object oriented programming. If you're unfamiliar with OOP in Python you can check out this tutorial by Corey Schafer. Now that you have these things you're ready to start the tutorial! Take Me to the Tutorial! Show Me the Credits","title":"Tutorial - Home"},{"location":"tutorial/#tutorial-home","text":"Before you start, there's a few things you will need to start developing bots: Nextcord Disnake An install of Python 3.8 or higher. An install of the Nextcord library. Linux and Mac Windows python3 -m pip install nextcord py -3 -m pip install nextcord An install of Python 3.8 or higher. An install of the Disnake library. Linux and Mac Windows python3 -m pip install disnake py -3 -m pip install disnake A working knowledge of Python basics or the will to learn. Especially object oriented programming. If you're unfamiliar with OOP in Python you can check out this tutorial by Corey Schafer. Now that you have these things you're ready to start the tutorial! Take Me to the Tutorial! Show Me the Credits","title":"Tutorial - Home"},{"location":"tutorial/beginner/01-setup/","text":"Creating a Bot User \u00b6 Info To create a bot application your Discord account must have a verified email address. It is also recommended that you enable 2-factor-authentication to secure your account. The first step in creating a bot is to head over to the Discord Developer Portal where you'll be asked to log in to your Discord account if you're not already signed in. Once you've logged in you'll see a screen like this: You can now click the shiny blue New Application button in the top hand corner to get started creating a new application. After you click it you should see a box like this pop up: Enter a suitable name for your application, and make sure that it follow Discord's Terms of Service. This applies to the entire tutorial too - you should not be using this tutorial for purposes that violate Discord's Terms of Service, Community Guidelines, or Developer Terms. You can read the Terms of Service here , and the Developer Terms here . Warning As a rough overview here are some things you should know about the ToS: Don't abuse the API. Don't harass users. So don't randomly DM or spam them. Don't spam Discord. Generally actions performed by a bot should be caused by some user action like sending a message or adding a reaction. Don't post NSFW content in channels not marked as NSFW. This may seem obvious but a lot of bots allow NSFW content to be posted outside of NSFW channels. This is not allowed. For the purposes of this tutorial we'll be using the name WumpusBot , and this will be referred to in other places in the tutorial, for example screenshots of commands. After creating an application you'll see a screen like this: There's quite a lot of information on this screen, so for now we'll ignore most of it since it's out of scope for the beginning of this tutorial. Click on the Bot tab on the left hand side (marked by a jigsaw piece) to switch to the bot page. On this page you'll see a button that says Add Bot. Clicking this will prompt you asking whether you're sure you want to create a new bot (you can't delete bots since they're too cool to destroy), click Yes, do it! and now you have your very own bot. After creating a bot your screen will change to look like this: Below the username box you'll see a button that says Copy which copies your bot's authentication token to your clipboard. You'll want to keep this token safe and on hand so your bot can connect to Discord later on in the tutorial. Warning Make sure never to post your token anywhere publicly, else people will be able to log in as your bot, and perform actions against the Discord API as your bot. If you believe that your bot\u2019s token was leaked, be sure to go to it\u2019s developer portal page and click the Regenerate button to regenerate the token so that nobody can use the old one. Finally for this part, you need to add your bot to your server. To do this you first require the Manage Server permission in whatever server you plan on adding it to. You\u2019ll want to head over to the OAuth2 tab on the left of the developer portal (marked by a wrench), where you\u2019ll be able to choose the scopes you want for your bot. For now, just select the bot scope, as it\u2019s all that will be needed for this tutorial - at least at the beginning. Now you\u2019ll want to choose permissions for your bot based on what you want it to do. For WumpusBot, I\u2019ll start by giving it Send Messages , Embed Links , Attach Files , Manage Messages , and Add Reactions , although we may need more permissions later, but that will be handled within Discord itself. Warning There are almost no circumstances under which your bot will ever need the Administrator permission. If you do not absolutely need it, you should not have it, as bots with administrator can destroy servers in seconds by deleting channels, mass-banning members, and a multitude of other unpleasant actions. For more info about this please read this tip about bot permissions . In the end your permissions should look like this: Now you can copy the URL in the box above, and paste it into your browser, then follow the steps to add the bot to your server of choice. As of late 2021 it is also possible to click invite links within Discord itself to add a bot to your server too. That's it for the first part of the tutorial, you've created your very own bot user on Discord. Now you just have to do the fun bit - adding features - after all, what's a bot without features?","title":"Creating a Bot User"},{"location":"tutorial/beginner/01-setup/#creating-a-bot-user","text":"Info To create a bot application your Discord account must have a verified email address. It is also recommended that you enable 2-factor-authentication to secure your account. The first step in creating a bot is to head over to the Discord Developer Portal where you'll be asked to log in to your Discord account if you're not already signed in. Once you've logged in you'll see a screen like this: You can now click the shiny blue New Application button in the top hand corner to get started creating a new application. After you click it you should see a box like this pop up: Enter a suitable name for your application, and make sure that it follow Discord's Terms of Service. This applies to the entire tutorial too - you should not be using this tutorial for purposes that violate Discord's Terms of Service, Community Guidelines, or Developer Terms. You can read the Terms of Service here , and the Developer Terms here . Warning As a rough overview here are some things you should know about the ToS: Don't abuse the API. Don't harass users. So don't randomly DM or spam them. Don't spam Discord. Generally actions performed by a bot should be caused by some user action like sending a message or adding a reaction. Don't post NSFW content in channels not marked as NSFW. This may seem obvious but a lot of bots allow NSFW content to be posted outside of NSFW channels. This is not allowed. For the purposes of this tutorial we'll be using the name WumpusBot , and this will be referred to in other places in the tutorial, for example screenshots of commands. After creating an application you'll see a screen like this: There's quite a lot of information on this screen, so for now we'll ignore most of it since it's out of scope for the beginning of this tutorial. Click on the Bot tab on the left hand side (marked by a jigsaw piece) to switch to the bot page. On this page you'll see a button that says Add Bot. Clicking this will prompt you asking whether you're sure you want to create a new bot (you can't delete bots since they're too cool to destroy), click Yes, do it! and now you have your very own bot. After creating a bot your screen will change to look like this: Below the username box you'll see a button that says Copy which copies your bot's authentication token to your clipboard. You'll want to keep this token safe and on hand so your bot can connect to Discord later on in the tutorial. Warning Make sure never to post your token anywhere publicly, else people will be able to log in as your bot, and perform actions against the Discord API as your bot. If you believe that your bot\u2019s token was leaked, be sure to go to it\u2019s developer portal page and click the Regenerate button to regenerate the token so that nobody can use the old one. Finally for this part, you need to add your bot to your server. To do this you first require the Manage Server permission in whatever server you plan on adding it to. You\u2019ll want to head over to the OAuth2 tab on the left of the developer portal (marked by a wrench), where you\u2019ll be able to choose the scopes you want for your bot. For now, just select the bot scope, as it\u2019s all that will be needed for this tutorial - at least at the beginning. Now you\u2019ll want to choose permissions for your bot based on what you want it to do. For WumpusBot, I\u2019ll start by giving it Send Messages , Embed Links , Attach Files , Manage Messages , and Add Reactions , although we may need more permissions later, but that will be handled within Discord itself. Warning There are almost no circumstances under which your bot will ever need the Administrator permission. If you do not absolutely need it, you should not have it, as bots with administrator can destroy servers in seconds by deleting channels, mass-banning members, and a multitude of other unpleasant actions. For more info about this please read this tip about bot permissions . In the end your permissions should look like this: Now you can copy the URL in the box above, and paste it into your browser, then follow the steps to add the bot to your server of choice. As of late 2021 it is also possible to click invite links within Discord itself to add a bot to your server too. That's it for the first part of the tutorial, you've created your very own bot user on Discord. Now you just have to do the fun bit - adding features - after all, what's a bot without features?","title":"Creating a Bot User"},{"location":"tutorial/beginner/02-overview/","text":"An Overview of Discord \u00b6 If you already have a decent understanding of WebSockets, the Discord API, and general Discord terminology, you can likely skip ahead to the next part in the tutorial. 1: The Gateway \u00b6 The gateway is just the Discord name for a WebSocket connection to Discord, following a specific protocol of packets that we need to send and receive. This is our bot's primary connection to Discord and means that instead of asking Discord repeatedly for events that have happened (known as polling), we just tell Discord which events we want to receive via gateway intents, and Discord will send us those events over the persistent socket we have connected with. When using client libraries like Nextcord and Disnake we don't need to worry too much about how this happens at such a low level, but it can help you to understand how each of the cogs in the machine works. Often it's helpful to understand the low-level architecture of a service like Discord, as it gives you a better understanding of how the service works at a higher level. Upon receiving an event from the gateway, the library will check the OP code of the packet, and then call the appropriate function in the library. Many of these OP codes are internal, such as resuming a session, identifying the client, and sending heartbeats, but some, like OP 10 (READY), are also dispatched as user facing events (specifically on_ready in this instance). Events with OP 0 - dispatch events, are the ones we will primarily use, as they contain events like MESSAGE_CREATE, MEMBER_UPDATE, and all the other useful events for building a functional bot. That's pretty much it for the gateway at this level. There is a lot more detail that can be talked about with the gateway, but that's out of the scope of this tutorial, and if you're interested in further reading the official Discord documentation for the gateway can be found here . 2: The API \u00b6 The API is how out bots talk back to Discord. We're receiving events from the gateway which deliver information to our bot, but when we want to respond to one of these events, for example automatically deleting a message with banned words in it, we need to make a request to Discord's REST API telling it to delete that message. If you've ever sent a message on Discord, added a reaction, renamed a channel, or done just about any other action in the client, you've interacted with the API before, you just haven't seen it. Bots have most of the same endpoints available as regular users, bar a few like adding friends, blocking people, and joining guilds. They do, however, have certain features exclusive to bots, like the ability to lock emojis to members with a certain role. As with the gateway, API calls are done behind the scenes and you don't need to manually interact with the API. This is useful as it abstracts away the difficult points of passing headers and handling rate limits. 3: Terminology \u00b6 In Discord there are a few special words for things which we need to understand and be able to differentiate between. The following table shows what a word means in the context of this tutorial. Term Description guild The internal word that Discord has for what you know as a server. user A Discord user, not containing information relating to a guild. member A Discord user, with guild context. You'll only receive members if you have the server members gateway intent enabled, which will be explained later, or sometimes in other events like voice state updates and as the author in message events. And that's pretty much it for this part of the tutorial. I hope this has given you at least some useful knowledge about roughly how Discord works, and now you can move on to the next part!","title":"An Overview of Discord"},{"location":"tutorial/beginner/02-overview/#an-overview-of-discord","text":"If you already have a decent understanding of WebSockets, the Discord API, and general Discord terminology, you can likely skip ahead to the next part in the tutorial.","title":"An Overview of Discord"},{"location":"tutorial/beginner/02-overview/#1-the-gateway","text":"The gateway is just the Discord name for a WebSocket connection to Discord, following a specific protocol of packets that we need to send and receive. This is our bot's primary connection to Discord and means that instead of asking Discord repeatedly for events that have happened (known as polling), we just tell Discord which events we want to receive via gateway intents, and Discord will send us those events over the persistent socket we have connected with. When using client libraries like Nextcord and Disnake we don't need to worry too much about how this happens at such a low level, but it can help you to understand how each of the cogs in the machine works. Often it's helpful to understand the low-level architecture of a service like Discord, as it gives you a better understanding of how the service works at a higher level. Upon receiving an event from the gateway, the library will check the OP code of the packet, and then call the appropriate function in the library. Many of these OP codes are internal, such as resuming a session, identifying the client, and sending heartbeats, but some, like OP 10 (READY), are also dispatched as user facing events (specifically on_ready in this instance). Events with OP 0 - dispatch events, are the ones we will primarily use, as they contain events like MESSAGE_CREATE, MEMBER_UPDATE, and all the other useful events for building a functional bot. That's pretty much it for the gateway at this level. There is a lot more detail that can be talked about with the gateway, but that's out of the scope of this tutorial, and if you're interested in further reading the official Discord documentation for the gateway can be found here .","title":"1: The Gateway"},{"location":"tutorial/beginner/02-overview/#2-the-api","text":"The API is how out bots talk back to Discord. We're receiving events from the gateway which deliver information to our bot, but when we want to respond to one of these events, for example automatically deleting a message with banned words in it, we need to make a request to Discord's REST API telling it to delete that message. If you've ever sent a message on Discord, added a reaction, renamed a channel, or done just about any other action in the client, you've interacted with the API before, you just haven't seen it. Bots have most of the same endpoints available as regular users, bar a few like adding friends, blocking people, and joining guilds. They do, however, have certain features exclusive to bots, like the ability to lock emojis to members with a certain role. As with the gateway, API calls are done behind the scenes and you don't need to manually interact with the API. This is useful as it abstracts away the difficult points of passing headers and handling rate limits.","title":"2: The API"},{"location":"tutorial/beginner/02-overview/#3-terminology","text":"In Discord there are a few special words for things which we need to understand and be able to differentiate between. The following table shows what a word means in the context of this tutorial. Term Description guild The internal word that Discord has for what you know as a server. user A Discord user, not containing information relating to a guild. member A Discord user, with guild context. You'll only receive members if you have the server members gateway intent enabled, which will be explained later, or sometimes in other events like voice state updates and as the author in message events. And that's pretty much it for this part of the tutorial. I hope this has given you at least some useful knowledge about roughly how Discord works, and now you can move on to the next part!","title":"3: Terminology"},{"location":"tutorial/beginner/03-hello/","text":"Hello, world \u00b6 In this part we'll create a basic slash command which just responds with \"Hello, world!\" to a /hello command. From this point onwards it is expected that you have either Nextcord or Disnake installed, as well as Python 3.8 or above. Nextcord Disnake To start off with slash commands in Nextcord, we'll need to import the nextcord.Client class, and create an instance of it which we can create commands on: import nextcord client = nextcord . Client () Awesome! Now that we have an instance of the client, we can create a command which responds to the /hello command: @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) There's quite a lot going on in that snippet, so allow me to explain what it all does: @client.slash_command(...) is a decorator which tells Nextcord that this is a slash command. name=\"hello\" is the name of the command. description=\"A simple hello command.\" is the description of the command. guild_ids=[...] is a list of guild IDs which the command is registered in, these should be int IDs of the guilds you want to register the command in. If this is empty it will be registered in all guilds, taking up to an hour to globally register. async def hello(inter: nextcord.Interaction) -> None is the function which will be called when the command is triggered. await inter.response.send_message(\"Hello!\") is the response which will be sent to the user. Finally, we can connect our bot to Discord by using Client.run() : client . run ( \"YOUR_BOT_TOKEN\" ) To start off with slash commands in Disnake we'll need to import the commands.Bot class, and also the CommandInteraction class for later use when defining the command: from disnake import CommandInteraction from disnake.ext.commands import Bot bot = Bot () Warning Remember, how you name your variables is important! This variable should be named bot , as it is an instance of the Bot class, and not something like client , which is a different class entirely. Awesome! Now that we have an instance of the bot, we can create a command which responds to the /hello command: @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : CommandInteraction ) -> None : await inter . send ( \"Hello!\" ) There's quite a lot going on in that snippet, so allow me to explain what it all does: @bot.slash_command(...) is a decorator which tells Disnake that this is a slash command. name=\"hello\" is the name of the command. description=\"A simple hello command.\" is the description of the command. guild_ids=[...] is a list of guild IDs which the command is registered in, these should be int IDs of the guilds you want to register the command in. If this is empty it will be registered in all guilds, taking up to an hour to globally register. async def hello(inter: CommandInteraction) -> None is the function which will be called when the command is triggered. await inter.send(\"Hello!\") is the response which will be sent to the user. Finally, we can connect our bot to Discord by using Bot.run() : bot . run ( \"YOUR_BOT_TOKEN\" ) Warning Storing tokens in your code like this is dangerous, if you upload a sample of your code to somewhere like Pastebin people could get your token and use it maliciously. It is recommended that you always store tokens in an environment variable or file, which is ignored by your version control system like Git. See Storing Tokens and Secrets for more information about how to correctly store application credentials. In the end you should have a command that looks like this: message:03-01.json That's it for this part! You're now ready to move on to ever more green and complex pastures!","title":"Hello, world"},{"location":"tutorial/beginner/03-hello/#hello-world","text":"In this part we'll create a basic slash command which just responds with \"Hello, world!\" to a /hello command. From this point onwards it is expected that you have either Nextcord or Disnake installed, as well as Python 3.8 or above. Nextcord Disnake To start off with slash commands in Nextcord, we'll need to import the nextcord.Client class, and create an instance of it which we can create commands on: import nextcord client = nextcord . Client () Awesome! Now that we have an instance of the client, we can create a command which responds to the /hello command: @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) There's quite a lot going on in that snippet, so allow me to explain what it all does: @client.slash_command(...) is a decorator which tells Nextcord that this is a slash command. name=\"hello\" is the name of the command. description=\"A simple hello command.\" is the description of the command. guild_ids=[...] is a list of guild IDs which the command is registered in, these should be int IDs of the guilds you want to register the command in. If this is empty it will be registered in all guilds, taking up to an hour to globally register. async def hello(inter: nextcord.Interaction) -> None is the function which will be called when the command is triggered. await inter.response.send_message(\"Hello!\") is the response which will be sent to the user. Finally, we can connect our bot to Discord by using Client.run() : client . run ( \"YOUR_BOT_TOKEN\" ) To start off with slash commands in Disnake we'll need to import the commands.Bot class, and also the CommandInteraction class for later use when defining the command: from disnake import CommandInteraction from disnake.ext.commands import Bot bot = Bot () Warning Remember, how you name your variables is important! This variable should be named bot , as it is an instance of the Bot class, and not something like client , which is a different class entirely. Awesome! Now that we have an instance of the bot, we can create a command which responds to the /hello command: @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : CommandInteraction ) -> None : await inter . send ( \"Hello!\" ) There's quite a lot going on in that snippet, so allow me to explain what it all does: @bot.slash_command(...) is a decorator which tells Disnake that this is a slash command. name=\"hello\" is the name of the command. description=\"A simple hello command.\" is the description of the command. guild_ids=[...] is a list of guild IDs which the command is registered in, these should be int IDs of the guilds you want to register the command in. If this is empty it will be registered in all guilds, taking up to an hour to globally register. async def hello(inter: CommandInteraction) -> None is the function which will be called when the command is triggered. await inter.send(\"Hello!\") is the response which will be sent to the user. Finally, we can connect our bot to Discord by using Bot.run() : bot . run ( \"YOUR_BOT_TOKEN\" ) Warning Storing tokens in your code like this is dangerous, if you upload a sample of your code to somewhere like Pastebin people could get your token and use it maliciously. It is recommended that you always store tokens in an environment variable or file, which is ignored by your version control system like Git. See Storing Tokens and Secrets for more information about how to correctly store application credentials. In the end you should have a command that looks like this: message:03-01.json That's it for this part! You're now ready to move on to ever more green and complex pastures!","title":"Hello, world"},{"location":"tutorial/beginner/04-pong/","text":"A Ping Command \u00b6 So far our bot is pretty simple - you type /hello and the bot responds with \"Hello!\" as a static response, which isn't particularly interesting. In this tutorial part we'll use useful information from our bot - its gateway latency - to respond with a more interesting response about the bot's performance. Here's the code from the previous part: Nextcord Disnake import nextcord client = nextcord . Client () @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) from disnake import CommandInteraction from disnake.ext.commands import Bot bot = Bot () @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : CommandInteraction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) The code we will be writing in a second will go just above the bot.run() call. Firstly we'll start out by defining the command again: Nextcord Disnake @client . slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ], ) async def ping ( inter : nextcord . Interaction ) -> None : And next we'll add in the magical line which shows us the bot's latency: await inter . response . send_message ( f \"Pong! { client . latency * 1000 : .2f } ms\" ) @bot . slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ], ) async def ping ( inter : CommandInteraction ) -> None : And next we'll add in the magical line which shows us the bot's latency: await inter . send ( f \"Pong! { bot . latency * 1000 : .2f } ms\" ) Note The final line here is indented by one indent. Make sure to reflect this in your own code. Most of this you have seen before in the previous part, but the important bit is the line which says either: await inter.response.send_message(f\"Pong! {client.latency * 1000:.2f}ms\") (Nextcord) await inter.send(f\"Pong! {bot.latency * 1000:.2f}ms\") (Disnake) The latency property of the bot or client tells us in seconds how long it took for the Discord gateway to respond to us last time we sent it a heartbeat payload (which keeps the connection alive). We multiply this by 1000 to get the latency in milliseconds, which is better for being interpreted, and is more standard, and then we round it to 2 decimal places using the :.2f format specifier. Now you can once again run your bot - having changed the guild_ids=[...] to contain your own guild IDs - and you'll be able to use the command like this: message:04-01.json That's it for this part! Now you're ready to move on to the next part: listening for events!","title":"A Ping Command"},{"location":"tutorial/beginner/04-pong/#a-ping-command","text":"So far our bot is pretty simple - you type /hello and the bot responds with \"Hello!\" as a static response, which isn't particularly interesting. In this tutorial part we'll use useful information from our bot - its gateway latency - to respond with a more interesting response about the bot's performance. Here's the code from the previous part: Nextcord Disnake import nextcord client = nextcord . Client () @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) from disnake import CommandInteraction from disnake.ext.commands import Bot bot = Bot () @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : CommandInteraction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) The code we will be writing in a second will go just above the bot.run() call. Firstly we'll start out by defining the command again: Nextcord Disnake @client . slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ], ) async def ping ( inter : nextcord . Interaction ) -> None : And next we'll add in the magical line which shows us the bot's latency: await inter . response . send_message ( f \"Pong! { client . latency * 1000 : .2f } ms\" ) @bot . slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ], ) async def ping ( inter : CommandInteraction ) -> None : And next we'll add in the magical line which shows us the bot's latency: await inter . send ( f \"Pong! { bot . latency * 1000 : .2f } ms\" ) Note The final line here is indented by one indent. Make sure to reflect this in your own code. Most of this you have seen before in the previous part, but the important bit is the line which says either: await inter.response.send_message(f\"Pong! {client.latency * 1000:.2f}ms\") (Nextcord) await inter.send(f\"Pong! {bot.latency * 1000:.2f}ms\") (Disnake) The latency property of the bot or client tells us in seconds how long it took for the Discord gateway to respond to us last time we sent it a heartbeat payload (which keeps the connection alive). We multiply this by 1000 to get the latency in milliseconds, which is better for being interpreted, and is more standard, and then we round it to 2 decimal places using the :.2f format specifier. Now you can once again run your bot - having changed the guild_ids=[...] to contain your own guild IDs - and you'll be able to use the command like this: message:04-01.json That's it for this part! Now you're ready to move on to the next part: listening for events!","title":"A Ping Command"},{"location":"tutorial/beginner/05-listeners/","text":"Event Listeners \u00b6 While a lot of bot functionality can be implemented with slash commands, there are features that cannot be implemented like this. For example if you want to delete messages containing a certain keyword, you cannot do that with slash commands, but you can do it with listeners for other events, such as messages. Just like previous parts we'll want a basic bot to be set up. In this example we will be automatically deleting any message that contains the word \"badword\" in it. For simplicity I have removed the ping command from the basic bots below. Nextcord Disnake import nextcord client = nextcord . Client () @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) from disnake import CommandInteraction , Message from disnake.ext.commands import Bot bot = Bot () @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : CommandInteraction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note We are importing Message here so that we can type hint the message parameter of the on_message listener later on. Next we'll create a listener that will delete any message that contains the word \"badword\" in it, again this is inserted just above the bot.run() call: Nextcord Disnake @client . event async def on_message ( message : nextcord . Message ) -> None : if \"badword\" in message . content : await message . delete () @bot . listener () async def on_message ( message : Message ) -> None : if \"badword\" in message . content : await message . delete () Here's a breakdown of what we're doing here: @bot.listener() is a decorator which tells Disnake that this is an event listener. async def on_message(message: Message) -> None is the function which will be called when the event is triggered. message is the message that triggered the event. if \"badword\" in message.content is a check to see if the message contains the word \"badword\" in it. await message.delete() deletes the message the user sent. Note This is a very simple example of using a listener for events. Much more complex tasks can be achieved using listeners, but they are out of scope for this beginner part. More complex examples will be given in later intermediate parts.","title":"Event Listeners"},{"location":"tutorial/beginner/05-listeners/#event-listeners","text":"While a lot of bot functionality can be implemented with slash commands, there are features that cannot be implemented like this. For example if you want to delete messages containing a certain keyword, you cannot do that with slash commands, but you can do it with listeners for other events, such as messages. Just like previous parts we'll want a basic bot to be set up. In this example we will be automatically deleting any message that contains the word \"badword\" in it. For simplicity I have removed the ping command from the basic bots below. Nextcord Disnake import nextcord client = nextcord . Client () @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) from disnake import CommandInteraction , Message from disnake.ext.commands import Bot bot = Bot () @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : CommandInteraction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note We are importing Message here so that we can type hint the message parameter of the on_message listener later on. Next we'll create a listener that will delete any message that contains the word \"badword\" in it, again this is inserted just above the bot.run() call: Nextcord Disnake @client . event async def on_message ( message : nextcord . Message ) -> None : if \"badword\" in message . content : await message . delete () @bot . listener () async def on_message ( message : Message ) -> None : if \"badword\" in message . content : await message . delete () Here's a breakdown of what we're doing here: @bot.listener() is a decorator which tells Disnake that this is an event listener. async def on_message(message: Message) -> None is the function which will be called when the event is triggered. message is the message that triggered the event. if \"badword\" in message.content is a check to see if the message contains the word \"badword\" in it. await message.delete() deletes the message the user sent. Note This is a very simple example of using a listener for events. Much more complex tasks can be achieved using listeners, but they are out of scope for this beginner part. More complex examples will be given in later intermediate parts.","title":"Event Listeners"},{"location":"tutorial/intermediate/","text":"Intermediate - Home \u00b6 This section of the tutorial is for intermediate users of Nextcord and Disnake. It aims to cover more advanced features which are less common in smaller application, but which may be required for larger projects. Note From this point onwards only library features will be explained. All Python feature knowledge is assumed. Continue for Nextcord Continue for Disnake","title":"Intermediate - Home"},{"location":"tutorial/intermediate/#intermediate-home","text":"This section of the tutorial is for intermediate users of Nextcord and Disnake. It aims to cover more advanced features which are less common in smaller application, but which may be required for larger projects. Note From this point onwards only library features will be explained. All Python feature knowledge is assumed. Continue for Nextcord Continue for Disnake","title":"Intermediate - Home"},{"location":"tutorial/intermediate/disnake/11-cogs/","text":"Cogs \u00b6 Cogs are an important part of Disnake which allow you to organise your events and commands into different files. They represent a fairly drastic change in how you write your events, commands, and bots, so it's useful to do them early on before you have too much logic in your main file. Note Cogs require a basic understanding of OOP/classes in Python. If you're not familiar with this, check out the first video in Corey Schafer's OOP Tutorial . Now that we're using cogs we're going to abandon most of the code we have from previous parts, since it needs to change significantly to be used with cogs, and some of the functionality we've implemented so far isn't very useful anyway. Note In this part I'll refer to cogs and extensions, and the difference between both is important. A cog is a single class that inherits from Cog , which encapsulates commands and events. An extension is a collection of cogs which has a setup function and can be loaded via the bot's load_extension method, although you will often find extensions with just one cog. As with the previous parts we need to create a bot object, we'll do this in a file named main.py : main.py from disnake.ext.commands import Bot bot = Bot () bot . run ( \"YOUR_BOT_TOKEN\" ) Now, we need to create a file that we'll put our cog in, let's call it ping.py as we'll be putting a basic ping command in here: ping.py from disnake.ext.commands import Bot , Cog , CommandInteraction , slash_command class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot @slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ]) async def ping ( self , inter : CommandInteraction ) -> None : await inter . send ( f \"Pong! { self . bot . latency * 1000 : .2f } ms\" ) As you can probably see, a lot of this is similar to the ping command we made in part 4 of the beginner section. There are a couple of important parts to explain which are different: We're now using the slash_command decorator from disnake.ext.commands . We can no longer use the bot object to make decorators since we don't have the bot object as it's in another file. Everything is now in a class. This is a fundamental part of cogs, all of their functionality is encapsulated within a class. In this section of code: class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot What we're doing is defining a new cog, and letting it take a bot object in its constructor. We're doing this so that we can then access that bot object for the ping command so we can retrieve the bot's websocket latency. We still have a final piece of code we need to add to the cog's file in order for the cog to be registered, a setup function: ping.py # This goes at the bottom of the file. def setup ( bot : Bot ) -> None : bot . add_cog ( Ping ( bot )) This function is what disnake looks for when loading an extension, and the function signature will always be setup(self, bot: Bot) -> None . Finally, we need to load the cog in our main file: main.py from disnake.ext.commands import Bot bot = Bot () bot . load_extension ( \"ping\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note that when loading an extension we omit the .py extension. Extensions are loaded via Python imports behind the scenes, so we reference them in the same way we would write an import. If you have an extension in ./cogs/ping.py you would load it with bot.load_extension(\"cogs.ping\") .","title":"Cogs"},{"location":"tutorial/intermediate/disnake/11-cogs/#cogs","text":"Cogs are an important part of Disnake which allow you to organise your events and commands into different files. They represent a fairly drastic change in how you write your events, commands, and bots, so it's useful to do them early on before you have too much logic in your main file. Note Cogs require a basic understanding of OOP/classes in Python. If you're not familiar with this, check out the first video in Corey Schafer's OOP Tutorial . Now that we're using cogs we're going to abandon most of the code we have from previous parts, since it needs to change significantly to be used with cogs, and some of the functionality we've implemented so far isn't very useful anyway. Note In this part I'll refer to cogs and extensions, and the difference between both is important. A cog is a single class that inherits from Cog , which encapsulates commands and events. An extension is a collection of cogs which has a setup function and can be loaded via the bot's load_extension method, although you will often find extensions with just one cog. As with the previous parts we need to create a bot object, we'll do this in a file named main.py : main.py from disnake.ext.commands import Bot bot = Bot () bot . run ( \"YOUR_BOT_TOKEN\" ) Now, we need to create a file that we'll put our cog in, let's call it ping.py as we'll be putting a basic ping command in here: ping.py from disnake.ext.commands import Bot , Cog , CommandInteraction , slash_command class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot @slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ]) async def ping ( self , inter : CommandInteraction ) -> None : await inter . send ( f \"Pong! { self . bot . latency * 1000 : .2f } ms\" ) As you can probably see, a lot of this is similar to the ping command we made in part 4 of the beginner section. There are a couple of important parts to explain which are different: We're now using the slash_command decorator from disnake.ext.commands . We can no longer use the bot object to make decorators since we don't have the bot object as it's in another file. Everything is now in a class. This is a fundamental part of cogs, all of their functionality is encapsulated within a class. In this section of code: class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot What we're doing is defining a new cog, and letting it take a bot object in its constructor. We're doing this so that we can then access that bot object for the ping command so we can retrieve the bot's websocket latency. We still have a final piece of code we need to add to the cog's file in order for the cog to be registered, a setup function: ping.py # This goes at the bottom of the file. def setup ( bot : Bot ) -> None : bot . add_cog ( Ping ( bot )) This function is what disnake looks for when loading an extension, and the function signature will always be setup(self, bot: Bot) -> None . Finally, we need to load the cog in our main file: main.py from disnake.ext.commands import Bot bot = Bot () bot . load_extension ( \"ping\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note that when loading an extension we omit the .py extension. Extensions are loaded via Python imports behind the scenes, so we reference them in the same way we would write an import. If you have an extension in ./cogs/ping.py you would load it with bot.load_extension(\"cogs.ping\") .","title":"Cogs"},{"location":"tutorial/intermediate/nextcord/11-cogs/","text":"Cogs \u00b6 Cogs are an important part of Nextcord which allow you to organise your events and commands into different files. They represent a fairly drastic change in how you write your events, commands, and bots, so it's useful to do them early on before you have too much logic in your main file. Note Cogs require a basic understanding of OOP/classes in Python. If you're not familiar with this, check out the first video in Corey Schafer's OOP Tutorial . Now that we're using cogs we're going to abandon most of the code we have from previous parts, since it needs to change significantly to be used with cogs, and some of the functionality we've implemented so far isn't very useful anyway. Note In this part I'll refer to cogs and extensions, and the difference between both is important. A cog is a single class that inherits from Cog , which encapsulates commands and events. An extension is a collection of cogs which has a setup function and can be loaded via the bot's load_extension method, although you will often find extensions with just one cog. In the previous parts with Nextcord we used the Client class since this supports slash commands natively, but as of right now the regular client does not support using Cogs, and as a result we will have to switch to using nextcord.ext.commands.Bot , which is essentially the same as nextcord.Client but supports loading extensions and cogs. Let's create a file named main.py and add in the base code: main.py from nextcord.ext.commands import Bot bot = Bot () bot . run ( \"YOUR_BOT_TOKEN\" ) Now, we need to create a file that we'll put our cog in, let's call it ping.py as we'll be putting a basic ping command in here: ping.py from nextcord import Interaction , slash_command from nextcord.ext.commands import Bot , Cog class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot @slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ]) async def ping ( self , inter : Interaction ) -> None : await inter . send ( f \"Pong! { self . bot . latency * 1000 : .2f } ms\" ) As you can probably see, a lot of this is similar to the ping command we made in part 4 of the beginner section. There are a couple of important parts to explain which are different: We're now using the slash_command decorator . We can no longer use the bot object to make decorators since we don't have the bot object as it's in another file. Everything is now in a class. This is a fundamental part of cogs, all of their functionality is encapsulated within a class. In this section of code: class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot What we're doing is defining a new cog, and letting it take a bot object in its constructor. We're doing this so that we can then access that bot object for the ping command so we can retrieve the bot's websocket latency. We still have a final piece of code we need to add to the cog's file in order for the cog to be registered, a setup function: ping.py # This goes at the bottom of the file. def setup ( bot : Bot ) -> None : bot . add_cog ( Ping ( bot )) This function is what nextcord looks for when loading an extension, and the function signature will always be setup(self, bot: Bot) -> None . Finally, we need to load the cog in our main file: main.py from nextcord.ext.commands import Bot bot = Bot () bot . load_extension ( \"ping\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note that when loading an extension we omit the .py extension. Extensions are loaded via Python imports behind the scenes, so we reference them in the same way we would write an import. If you have an extension in ./cogs/ping.py you would load it with bot.load_extension(\"cogs.ping\") .","title":"Cogs"},{"location":"tutorial/intermediate/nextcord/11-cogs/#cogs","text":"Cogs are an important part of Nextcord which allow you to organise your events and commands into different files. They represent a fairly drastic change in how you write your events, commands, and bots, so it's useful to do them early on before you have too much logic in your main file. Note Cogs require a basic understanding of OOP/classes in Python. If you're not familiar with this, check out the first video in Corey Schafer's OOP Tutorial . Now that we're using cogs we're going to abandon most of the code we have from previous parts, since it needs to change significantly to be used with cogs, and some of the functionality we've implemented so far isn't very useful anyway. Note In this part I'll refer to cogs and extensions, and the difference between both is important. A cog is a single class that inherits from Cog , which encapsulates commands and events. An extension is a collection of cogs which has a setup function and can be loaded via the bot's load_extension method, although you will often find extensions with just one cog. In the previous parts with Nextcord we used the Client class since this supports slash commands natively, but as of right now the regular client does not support using Cogs, and as a result we will have to switch to using nextcord.ext.commands.Bot , which is essentially the same as nextcord.Client but supports loading extensions and cogs. Let's create a file named main.py and add in the base code: main.py from nextcord.ext.commands import Bot bot = Bot () bot . run ( \"YOUR_BOT_TOKEN\" ) Now, we need to create a file that we'll put our cog in, let's call it ping.py as we'll be putting a basic ping command in here: ping.py from nextcord import Interaction , slash_command from nextcord.ext.commands import Bot , Cog class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot @slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ]) async def ping ( self , inter : Interaction ) -> None : await inter . send ( f \"Pong! { self . bot . latency * 1000 : .2f } ms\" ) As you can probably see, a lot of this is similar to the ping command we made in part 4 of the beginner section. There are a couple of important parts to explain which are different: We're now using the slash_command decorator . We can no longer use the bot object to make decorators since we don't have the bot object as it's in another file. Everything is now in a class. This is a fundamental part of cogs, all of their functionality is encapsulated within a class. In this section of code: class Ping ( Cog ): def __init__ ( self , bot : Bot ) -> None : self . bot = bot What we're doing is defining a new cog, and letting it take a bot object in its constructor. We're doing this so that we can then access that bot object for the ping command so we can retrieve the bot's websocket latency. We still have a final piece of code we need to add to the cog's file in order for the cog to be registered, a setup function: ping.py # This goes at the bottom of the file. def setup ( bot : Bot ) -> None : bot . add_cog ( Ping ( bot )) This function is what nextcord looks for when loading an extension, and the function signature will always be setup(self, bot: Bot) -> None . Finally, we need to load the cog in our main file: main.py from nextcord.ext.commands import Bot bot = Bot () bot . load_extension ( \"ping\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note that when loading an extension we omit the .py extension. Extensions are loaded via Python imports behind the scenes, so we reference them in the same way we would write an import. If you have an extension in ./cogs/ping.py you would load it with bot.load_extension(\"cogs.ping\") .","title":"Cogs"}]}